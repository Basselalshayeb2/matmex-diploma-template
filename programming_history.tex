% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macros see also
% https://tex.stackexchange.com/questions/78101/

% По умолчанию используется шрифт 14 размера.
% Если Вы не влезаете в лимит страниц и нужен 12-й шрифт,
% то уберите опцию [14pt]

\documentclass[14pt, russian]{matmex-diploma-custom}


\input{preamble.tex}

\begin{document}

\input{programming_history_title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\pagebreak

\section{Введение}
\thispagestyle{withCompileDate}
PHP традиционно играет важную роль в динамичном развитии веб-разработки в течение почти трех десятилетий.
Согласно актуальной статистике W3Techs\cite{W3Techs} по состоянию на 1 ноября 2025 года, PHP используется в 72.9\% всех веб-сайтов с известным серверным языком.

PHP\cite{phplatest} стал основой для многих систем управления контентом и прикладных веб-решений благодаря низкому порогу входа и широкой доступности хостинга.

Тем не менее, устойчивость языка и его экосистемы на протяжении столь длительного периода в значительной степени связана с развитием общих архитектурных практик и стандартов, которые определили индустрию PHP\cite{phplatest}-разработки.

В начале 2000-х годов появились первые PHP\cite{phplatest}-фреймворки. CakePHP (2005)\cite{cakephp2005announce}, Symfony (2005)\cite{symfony2005release} и CodeIgniter (2006)\cite{codeigniter2006announce} поставили основы MVC-подхода и организовали разработку веб-приложений без стандартов.

Тем не менее, по мере роста сложности веб-приложений стало очевидно, что архитектура 2000-х годов сталкивалась с важными ограничениями, такими как непрозрачная архитектура, несовместимость компонентов, отсутствие унифицированных интерфейсов и низкая тестируемость.

В течение следующих десяти лет (2005–2015) произошли значительные изменения в PHP\cite{phplatest}-стеке. Это было связано с разработкой PHP-FIG \cite{phpfig2010charter} и ряда стандартов PSR \cite{psr0standard}, появлением Composer \cite{seldaek2012composer}, унификацией HTTP-модели\cite{psr7standard}, распространением принципов DI \cite{psr11standard} и архитектурой middleware \cite{psr15standard}.

Тем не менее, между 2015 и 2025 годами произошли наиболее значительные структурные изменения в PHP\cite{phplatest}-фреймворке. Эти изменения радикально изменили архитектурные решения, принципы проектирования и практики масштабирования.

Эти изменения включали выход PHP 7\cite{php7rfc2015}, массовую типизацию и строгую модель ошибок, переход Symfony на компонентный подход, стремительный рост Laravel, падение Zend Framework и его перерождение в Laminas.

Цель этой работы состоит в том, чтобы проанализировать основные архитектурные и технологические изменения в PHP\cite{phplatest}-фреймворках за 2015–2025 годы, определить причины этих изменений, оценить эффективность принятых решений и определить, какие идеи были отвергнуты или изменились в ходе обсуждений.
В анализе используются материалы рассылок PHP-FIG\cite{phpfig2010charter}, предложения RFC Internals PHP, официальные публикации Symfony\cite{symfony2005release} и Laravel\cite{laravel2011announce}, дискуссии GitHub о стандартах Composer и PSR, а также выступления разработчиков на конференциях, таких как SymfonyCon\cite{symfonycon} и Laracon\cite{laracon}.

Таким образом, в статье рассматривается не только развитие определенных фреймворков, но и более широкий процесс создания профессиональной экосистемы PHP, в которой технологические решения являются основной движущей силой прогресса.


\section{Предпосылки: фрагментированная экосистема PHP до 2015 года и необходимость стандартизации}
К 2015 году промышленная разработка PHP\cite{phplatest} началась с противоречий.

С другой стороны, благодаря своей простоте развёртывания и широкой совместимости PHP\cite{phplatest} продолжал доминировать в веб-разработке.

Напротив, экосистема испытывала значительные архитектурные ограничения из-за отсутствия единых правил и несовместимости основных компонентов фреймворка.

Эти ограничения замедлили язык и фреймворки.

\subsection{Отсутствие единых интерфейсов и высокая фрагментация}

До того, как в экосистеме PHP появилась PHP-FIG\cite{phpfig2010charter}, не существовало общепризнанных соглашений по:

\begin{itemize}
    \item Система каталогов,
    \item Автоматическая загрузка классов,
    \item Форматы запросов и ответов HTTP,
    \item Интерфейсы контейнеров, которые зависят от зависимостей,
    \item Методы middleware.
\end{itemize}

Каждый фреймворк, включая Symfony\cite{symfony2005release}, Zend Framework\cite{zendframework2006announce}, CakePHP\cite{cakephp2005announce} и CodeIgniter\cite{codeigniter2006announce}, разработал свои собственные решения, которые часто не пересекались.

Что привело к эффекту «изолированных островов» в PHP-мире, заключалось в том, что библиотеки и инструменты не могли быть повторно использованы между проектами.

Например:

\begin{itemize}
    \item Symfony\cite{symfony2005release} использовал собственный автозагрузчик и собственные соглашения об именовании классов.
    \item Zend Framework\cite{zendframework2006announce} применял иной подход к структуре каталогов.
    \item Многие библиотеки требовали ручного подключения файлов и не имели механизма декларирования зависимостей.
\end{itemize}

Это создавало тесную связность между фреймворком и компонентами.
Интеграции часто строились на неформализованных паттернах, а меняющиеся детали реализации ломали совместимость.

\subsection{Проблема совместимости и отсутствие переиспользуемых компонентов}

Ключевой проблемой периода до 2012–2014 годов была невозможность использовать одну и ту же библиотеку в разных фреймворках.

Например, HTTP-клиенты, логгеры и шаблонизаторы были жестко «привязаны» к конкретному фреймворку, а попытки переносить решения приводили к конфликтам стилей, соглашений и точек расширения.

Symfony\cite{symfony2005release} первым попытался решить эту проблему, выделив «компонентный подход\cite{fabpot2012symfonycomponents}» (начиная с Symfony 2\cite{symfony2011release}), но без стандартизации на уровне индустрии это был лишь частичный шаг.

Разработчики других фреймворков могли использовать компоненты Symfony, но не было гарантий совместимости.


\subsection{Отсутствие стандартизированной модели HTTP}

Одним из главных технологических ограничений было отсутствие стандартизированного представления:

\begin{itemize}
    \item HTTP-запроса.
    \item HTTP-ответа.
    \item атрибутов, заголовков, стримов.
\end{itemize}

Каждый фреймворк определял собственные классы:

\begin{itemize}
    \item Symfony HttpFoundation \cite{symfonyhttpfoundation},
    \item Zend\\Http \cite{zendhttp} (Request / Response).
    \item Slim\\Http \cite{slimhttp}.
    \item Собственные реализации в CakePHP \cite{cakephphttp}.
\end{itemize}

Это делало невозможным:

\begin{itemize}
    \item Взаимозаменяемые middleware.
    \item Стандартные фильтры и обработчики.
    \item Переносимость кода между фреймворками.
    \item Унифицированные HTTP-клиенты.
\end{itemize}

Проблема была настолько глубокой, что в рассылке FIG обсуждение PSR-7\cite{psr7standard} длилось почти 3 года.
Это ещё один признак того, насколько фундаментальной была задача стандартизации.


\subsection{Отсутствие единых правил автозагрузки и зависимостей}

До релиза Composer \cite{seldaek2012composer} (2012) и PSR-4 \cite{psr4standard} (2013–2014):

\begin{itemize}
    \item Большинство библиотек подключались вручную через \texttt{require} или \texttt{include}.
    \item Не было декларативного управления зависимостями.
    \item Поставка кода происходила через ZIP-архивы или PEAR (который плохо поддерживался и был неинтуитивен).
\end{itemize}

\texttt{Autoloading} был одной из самых болезненных частей PHP-разработки:

\begin{itemize}
    \item Фреймворки требовали строгих соглашений по структуре каталогов.
    \item Библиотеки не могли легко объявлять свои зависимости.
    \item Конфликты версий были обычным делом.
\end{itemize}

Composer \cite{seldaek2012composer} радикально изменил эту ситуацию, но его широкое принятие началось только после 2014–2015 — и именно этот период стал отправной точкой изменений, анализируемых далее.

\subsection{Проблемы тестируемости и внедрения зависимостей}
До принятия PSR-11 \cite{psr11standard} (Container Interface) каждый фреймворк реализовывал собственный DI-контейнер, и ни один из них не был совместим с другим:

\begin{itemize}
    \item Symfony DependencyInjection \cite{symfonydependencyinjection}.
    \item Laravel Container \cite{laravelcontainer}.
    \item Zend\\ServiceManager \cite{zendservicemanager}.
    \item Pimple \cite{pimple}.
\end{itemize}

Отсутствие общего интерфейса:

\begin{itemize}
    \item Усложняло создание многоразовых пакетов.
    \item Делало невозможным перенос middleware-компонентов.
    \item Тормозило развитие архитектур, основанных на инверсии управления.
\end{itemize}

Архитектура DI\footnote{
    \textbf{DI — Dependency Injection}.
    Внедрение зависимостей: объект получает свои зависимости извне, а не создаёт их самостоятельно.
    } была одной из ключевых болевых точек, которую индустрия смогла решить только в последние 10 лет (2015–2025), в ходе стандартизации PSR-11 \cite{psr11standard}.

\setmonofont{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{programming_history}

\end{document}
