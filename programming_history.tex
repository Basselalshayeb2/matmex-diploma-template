% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macros see also
% https://tex.stackexchange.com/questions/78101/

% По умолчанию используется шрифт 14 размера.
% Если Вы не влезаете в лимит страниц и нужен 12-й шрифт,
% то уберите опцию [14pt]

\documentclass[14pt, russian]{matmex-diploma-custom}
\usepackage{listings}
\usepackage{xcolor}

\newcommand{\graybox}[1]{%
  \colorbox{lightgray}{\strut #1}%
}


\input{preamble.tex}

\begin{document}

\input{programming_history_title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\pagebreak

\section{Введение}
\thispagestyle{withCompileDate}
PHP играет важную роль в веб-разработке на протяжении почти трёх десятилетий, оставаясь одним из наиболее распространённых серверных языков.

Согласно статистике W3Techs по состоянию на 1 ноября 2025 года, PHP используется в 72.9\% веб-сайтов с определённым языком серверной части \cite{W3Techs}.

Широкая доступность хостинга и относительно низкий порог входа сделали PHP \cite{phplatest} основой для множества систем управления контентом и прикладных веб-решений.

Однако, устойчивость языка и его экосистемы на протяжении длительного периода в значительной степени связана с развитием общих архитектурных практик и стандартов, которые определили индустрию PHP \cite{phplatest}-разработки.

В начале 2000-х годов в ответ на растущую сложность веб-приложений начали формироваться первые полнофункциональные PHP-фреймворки.

CakePHP (2005) \cite{cakephp2005announce}, Symfony (2005) \cite{symfony2005release} и CodeIgniter (2006) \cite{codeigniter2006announce} заложили основы MVC-подхода и упорядочили разработку веб-приложений в условиях отсутствия единых стандартов.

Однако по мере усложнения проектов стало очевидно, что решения того периода сталкиваются с рядом системных ограничений, включая непрозрачную архитектуру, несовместимость компонентов, отсутствие унифицированных интерфейсов и недостаточную тестируемость.

В течение следующего десятилетия (2005–2015) PHP \cite{phplatest}-стек претерпел значительные изменения. Это было связано с разработкой PHP-FIG \cite{phpfig2009charter} и ряда стандартов PSR \cite{psr0standard}, появлением Composer \cite{seldaek2012composer}, унификацией HTTP-модели \cite{psr7standard}, распространением принципов DI \cite{psr11standard} и архитектурой middleware \cite{psr15standard}.

Тем не менее, между 2015 и 2025 годами произошли наиболее значительные структурные изменения в PHP-фреймворках. Эти изменения радикально изменили архитектурные решения, принципы проектирования и практики масштабирования.

Эти преобразования охватывали выход PHP 7 \cite{php7rfc2015}, внедрение массовой типизации и переход к строгой модели обработки ошибок, реорганизацию Symfony \cite{symfony2005release} в рамках компонентной архитектуры, стремительный развитие Laravel \cite{laravel2011announce}, а также упадок Zend \cite{zendframework2006announce} Framework и его последующую трансформацию в проект Laminas.

Цель настоящей работы — провести комплексный анализ ключевых архитектурных и технологических изменений, произошедших в PHP-фреймворках в период с 2015 по 2025 годы. В рамках исследования предполагается выявить причины указанных изменений, оценить эффективность принятых техническиатурных решений, а также определить, какие концепции и подходы были отвергнуты или модифицированы в ходе профессиональных дискуссий.

Для достижения поставленных целей используются следующие источники: материалы рассылок PHP-FIG \cite{phpfig2009charter}, предложения RFC Internals PHP, официальные публикации Symfony \cite{symfony2005release} и Laravel \cite{laravel2011announce}, дискуссии GitHub о стандартах Composer и PSR, а также доклады разработчиков, представленные на профильных конференциях — в частности, SymfonyCon \cite{symfonycon} и Laracon \cite{laracon}.

Таким образом, в статье рассматривается не только эволюция отдельных фреймворков, но и более широкий процесс формирования профессиональной PHP-экосистемы, в которой технологические инновации выступают в качестве ключевого фактора развития.

\section{Особенности развития PHP-экосистемы до стандартизации (до 2015 года)}

К 2015 году промышленная разработка на PHP \cite{phplatest} характеризовалась двойственным положением. С одной стороны, язык сохранял широкое распространение и технологическую зрелость как платформа для веб-приложений, обусловленную простотой развёртывания, высокой доступностью хостинговых решений и устойчивой обратной совместимостью. С другой стороны, PHP-экосистема страдала от существенных архитектурных ограничений, вызванных отсутствием унифицированных стандартов проектирования и низкой совместимостью между ключевыми компонентами. Это приводило к увеличению совокупной стоимости сопровождения проектов, а также замедляло темпы развития как сторонних библиотек, так и фреймворков.
\subsection{Отсутствие единых интерфейсов}
До появления PHP-FIG \cite{phpfig2009charter} в экосистеме PHP отсутствовали общепринятые технические соглашения по ключевым аспектам разработки, включая:

\begin{itemize}
    \item организацию структуры каталогов;
    \item механизмы автоматической загрузки классов;
    \item унифицированное представление HTTP-запросов и ответов;
    \item интерфейсы контейнеров внедрения зависимостей (DI);
    \item стандартные контракты для middleware и модель обработки HTTP-запросов.
\end{itemize}

В результате каждый из ведущих фреймворков, включая Symfony \cite{symfony2005release}, Zend \cite{zendframework2006announce}, CakePHP \cite{cakephp2005announce} и CodeIgniter \cite{codeigniter2006announce}, реализовывал собственные, зачастую несовместимые подходы к решению этих задач. Это привело к эффекту фрагментации экосистемы PHP, при котором фреймворки и библиотеки развивались как изолированные подсистемы с ограниченной совместимостью.

Например, Symfony \cite{symfony2005release} применял собственный автозагрузчик и строгие соглашения об именовании, тогда как Zend предлагал иную структуру каталогов. Многие сторонние библиотеки того времени подключались вручную и не содержали формализованных метаданных о зависимостях, что исключало автоматизированное управление ими.

Такая ситуация приводила к высокой степени связанности между фреймворками и их компонентами. Интеграционные решения часто основывались на неформализованных соглашениях и паттернах, а изменения в деталях реализации нарушали обратную совместимость.

\subsection{Проблема совместимости и отсутствие компонентов повторного использования}

Ключевая проблема данного периода заключалась в невозможности использовать одну и ту же библиотеку в разных фреймворках. Такие распространённые компоненты, как HTTP-клиенты, инструменты логгирования и шаблонизаторы, были тесно интегрированы в архитектуру конкретных фреймворков и зависели от их внутренних соглашений, стилей кодирования и точек расширения. Попытки переноса подобных решений между проектами зачастую приводили к конфликтам, обусловленным различиями в API, структуре кода и механизмах интеграции.

Symfony \cite{symfony2005release} стал одним из первых фреймворков, предпринявших системную попытку преодолеть эту фрагментацию за счёт внедрения компонентного подхода \cite{fabpot2012symfonycomponents} (начиная с Symfony 2 \cite{symfony2011release}), однако в отсутствие общепринятых отраслевых стандартов такой подход оставался локальным решением, которое не обеспечивало гарантированной совместимости и стабильности интеграций.

\subsection{Отсутствие стандартизированной модели HTTP}

Одним из ключевых технологических ограничений PHP-экосистемы до появления общих стандартов являлось отсутствие унифицированного представления основных HTTP-компонентов: запроса, ответа, а также их атрибутов, заголовков и потоков данных.

Каждый из ведущих фреймворков реализовывал собственные, несовместимые между собой классы для работы с HTTP-слоем:

\begin{itemize}
    \item HttpFoundation \cite{symfonyhttpfoundation} в Symfony;
    \item Http \cite{zendhttp} (Request / Response) в Zend;
    \item Http \cite{slimhttp} в Slim;
    \item Собственные реализации в CakePHP \cite{cakephphttp}.
\end{itemize}

Такая фрагментация затрудняла разработку взаимозаменяемых middleware-компонентов, снижала переносимость кода между проектами и препятствовала созданию единых решений для HTTP-клиентов, фильтров и других инструментов обработки запросов.

Глубина проблемы подтверждается продолжительностью обсуждения стандарта PSR-7 \cite{psr7standard} в рабочих группах PHP-FIG: дискуссии по его формулировке велись почти три года. Это свидетельствует о фундаментальном характере задачи стандартизации HTTP-интерфейсов для всей экосистемы.

\subsection{Отсутствие единых правил для автозагрузки и управления зависимостями}

До появления Composer \cite{seldaek2012composer} и принятия стандарта PSR-4 \cite{psr4standard} (2013–2014 гг.) подключение сторонних библиотек в PHP-проектах, как правило, осуществлялось вручную с использованием конструкций \texttt{require/include}. Декларативное управление зависимостями фактически отсутствовало, а распространение кода происходило преимущественно через архивы в формате ZIP или посредством системы PEAR.

Отсутствие унифицированных правил автозагрузки классов обусловливало жёсткую привязку к структуре каталогов и способствовало частым конфликтам версий библиотек.

Ситуация принципиально изменилась с появлением Composer \cite{seldaek2012composer}, который ввёл централизованный и декларативный механизм управления зависимостями и автозагрузкой. Однако его широкое внедрение в промышленную разработку началось лишь в 2014–2015 гг. Этот период стал отправной точкой для изменений, анализируемых в последующих разделах.

\subsection{Проблемы тестируемости и внедрения зависимостей}
До принятия стандарта PSR-11 \cite{psr11standard} (Container Interface) каждый из ведущих PHP-фреймворков реализовывал собственный контейнер внедрения зависимостей (DI-контейнер), причём эти реализации не были совместимы между собой. К числу наиболее распространённых решений относились:


\begin{itemize}
    \item Symfony Dependency Injection \cite{symfonydependencyinjection};
    \item Laravel Container \cite{laravelcontainer};
    \item Zend Service Manager \cite{zendservicemanager};
    \item Pimple \cite{pimple}.
\end{itemize}

Отсутствие унифицированного интерфейса контейнера создавало ряд системных ограничений:

\begin{itemize}
    \item затрудняло разработку многократно используемых пакетов, не привязанных к конкретному фреймворку;
    \item делало невозможным перенос middleware-компонентов и других сервисов между проектами;
    \item замедляло развитие архитектур, основанных на принципах внедрения зависимостей и их управления.
\end{itemize}

Таким образом, архитектура внедрения зависимостей представляла собой одну из ключевых проблем экосистемы PHP, решение которой стало возможным лишь в последние 10 лет (2015–2025) в ходе стандартизации — в частности, с принятием PSR-11 \cite{psr11standard}.

\section{Развитие стандартов и архитектурных решений в экосистеме PHP (2015–2025)}

Период 2015–2025 годов стал для PHP-фреймворков этапом глубокой технологической трансформации.

В предшествующее десятилетие (2005–2015) были сформулированы и заложены фундаментальные концепции, определившие дальнейшее развитие экосистемы: создание PHP-FIG \cite{phpfig2009charter}, появление менеджера зависимостей Composer \cite{seldaek2012composer}, а также разработка PSR, первых стандартов PHP \cite{psr0standard}, включая PSR-4 \cite{psr4standard}, PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard}.

Однако качественный переход к современной архитектуре веб-приложений начался лишь после выхода PHP 7 \cite{php7rfc2015} и  широкого внедрения ключевых стандартов — PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard} и PSR-15 \cite{psr15standard}.

В данном разделе рассматриваются ключевые архитектурные изменения, произошедшие в указанный период, анализируются предпосылки их возникновения и оценивается их влияние на эволюцию PHP-экосистемы.

\subsection{Composer как фундамент модернизации экосистемы}

Менеджер зависимостей Composer \cite{seldaek2012composer} был впервые выпущен в 2012 году, однако его широкое внедрение в PHP-экосистеме произошло в 2015–2017 гг. Именно в этот период подавляющее большинство фреймворков и сторонних библиотек перешли на декларативную модель управления зависимостями.

Как отмечалось выше, до внедрения Composer управление зависимостями оставалось фрагментированным и неформализованным, что создавало ряд проблем при сопровождении крупных проектов и осложняло архитектурную эволюцию фреймворков.

Composer предложил унифицированное решение, включавшее декларативное описание зависимостей с помощью \texttt{composer.json} \cite{composerJsonSchema}, стандартизированный механизм автозагрузки классов на основе PSR-4 \cite{psr4standard}, поддержку семантического версионирования (SemVer) \cite{semver} и централизованный репозиторий пакетов Packagist \cite{packagist}.

Благодаря этим инновациям архитектурная парадигма PHP-фреймворков трансформировалась: они перестали восприниматься как монолитные системы и стали рассматриваться как композиции слабосвязанных, автономных компонентов, пригодных к обособленному выбору, комбинированию и обновлению.

К началу 2020-х годов Composer фактически закрепился в качестве инфраструктурного стандарта PHP-экосистемы. Это привело к снижению привязки библиотек к конкретным фреймворкам, ускорению обмена компонентами между проектами и формированию устойчивой культуры разработки фреймворк-независимых пакетов, ориентированных на повторное использование.

% \subsubsection{Причины изменения:}
% До Composer \cite{seldaek2012composer} управление зависимостями основывалось на:
% \begin{itemize}
%     \item Ручном подключении файлов через \texttt{require} или \texttt{include}.
%     \item Распространении пакетов через \texttt{ZIP}-архивы или \texttt{PEAR}.
%     \item Отсутствии разрешения конфликтов версий.
% \end{itemize}

% Это приводило к «зависимостному аду» \cite{dependencyHellWikipedia} и мешало развитию фреймворков.

% \subsubsection{Принятое решение}

% Composer \cite{seldaek2012composer} ввёл:

% \begin{itemize}
%     \item файл \texttt{composer.json} \cite{composerJsonSchema} в качестве декларации зависимостей.
%     \item Автозагрузчик, основанный на PSR-4 \cite{psr4standard}.
%     \item Семантическое версионирование \cite{semver}.
%     \item Центральный репозиторий \texttt{Packagist} \cite{packagist}.
% \end{itemize}

% Философия Composer \cite{seldaek2012composer} повлияла на всю экосистему: фреймворки стали не «монолитами», а наборами компонентов, которые можно выбирать, комбинировать и обновлять независимо.


% \subsubsection{Результаты}
% \begin{itemize}
%     \item Исчезла жёсткая привязка библиотек к конкретным фреймворкам.
%     \item Появилось огромное количество независимых пакетов.
%     \item Разработчики получили прозрачное управление зависимостями.
% \end{itemize}
% Composer \cite{seldaek2012composer} стал фактическим стандартом и сделал возможным внедрение последующих PSR.
\subsection{Развитие PSR и их роль в архитектурной трансформации PHP-экосистемы}

Стандарты PSR, разрабатываемые в рамках PHP-FIG \cite{phpfig2009charter}, стали центральным инструментом преодоления архитектурной фрагментации PHP-экосистемы в период 2015–2025 годов. В отличие от ранних инициатив по унификации, ориентированных на внутреннюю архитектуру отдельных фреймворков, PSR-стандарты были направлены на установление минимальных, но строго определённых контрактов, обеспечивающих совместимость между фреймворками без навязывания конкретных реализаций.
Эта стратегия позволила сформировать общий архитектурный «язык», на котором могли взаимодействовать разнородные компоненты, независимо от их происхождения. Каждый из ключевых стандартов решал узкую, но критически важную проблему совместимости, при этом внося вклад в общую картину модульной и переносимой архитектуры.
В следующих подразделах рассматриваются наиболее влиятельные PSR-стандарты, сыгравшие решающую роль в трансформации PHP-экосистемы: их предпосылки, ключевые положения и архитектурные последствия.
\subsubsection{PSR-4 и единая модель автозагрузки (2015)}

Стандарт PSR-4 \cite{psr4standard} стал решающим этапом в переходе от фрагментированных, фреймворк-специфичных соглашений к единой и предсказуемой модели автозагрузки классов в PHP-экосистеме.
Его практическое значение особенно возросло в период 2015–2020 годов, когда основные фреймворки начали систематически приводить структуру каталогов и организацию пространств имён в соответствие с PSR-4 \cite{psr4standard}. Это, в свою очередь, предоставило менеджеру зависимостей Composer устойчивую основу для генерации стандартизированного автозагрузчика, совместимого с любым соответствующим пакетом.
До принятия PSR-4 \cite{psr4standard} каждый крупный фреймворк использовал собственные, несовместимые между собой правила сопоставления имён классов с путями к файлам. Такая фрагментация затрудняла интеграцию сторонних библиотек, увеличивала сложность сопровождения и негативно сказывалась на масштабируемости проектов.
В отличие от прежней ситуации, когда каждая платформа определяла собственные правила, PSR-4 \cite{psr4standard} формализовал два ключевых принципа: во-первых, строгое соответствие между пространствами имён и иерархией каталогов; во-вторых, возможность автоматической загрузки классов без необходимости использования конструкций \texttt{include} или \texttt{require}.
В результате значительно повысилась переносимость библиотек между проектами, а архитектура фреймворков стала более компонентной: сократилась доля проприетарного инфраструктурного кода, а уровень взаимной совместимости в экосистеме в целом существенно возрос.

% PSR-4 \cite{psr4standard} (2014) стал ключевым переходом от хаотичных соглашений к единообразной системе.

% Но именно в период 2015–2020, когда фреймворки начали массово переписывать внутренние структуры под PSR-4 \cite{psr4standard}.

% \subsubsection{Причины}
% До PSR-4 \cite{psr4standard}:
% \begin{itemize}
%     \item Каждый фреймворк имел собственные правила размещения классов.
%     \item Не было единообразных пространств имён.
%     \item Библиотеки не могли интегрироваться между собой.
% \end{itemize}


% \subsubsection{Принятое решение}
% PSR-4 \cite{psr4standard} определил:
% \begin{itemize}
%     \item Строгие правила сопоставления пространств имён с каталогами.
%     \item Автоматическую загрузку классов без ручных \texttt{include} или \texttt{require}.
% \end{itemize}

% \subsubsection{Результаты}
% \begin{itemize}
%     \item Библиотеки стали взаимозаменяемыми.
%     \item Фреймворки уменьшили собственный «клей» и стали ориентироваться на компоненты.
%     \item Composer \cite{seldaek2012composer} получил техническую основу для генерации стандартизированного автозагрузчика.
% \end{itemize}

% PSR-4 \cite{psr4standard} стал первым шагом к «общему грамматическому строю» всей экосистемы.


\subsubsection{PSR-7 и стандартизация HTTP-модели (2015)}

Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из ключевых факторов в эволюции архитектуры PHP-экосистемы.
До его принятия HTTP-запросы и ответы в каждом фреймворке реализовывались с использованием собственных, несовместимых между собой моделей. Это препятствовало переносу middleware-компонентов и делало практически невозможной разработку взаимозаменяемых HTTP-инструментов — таких как клиенты, маршрутизаторы или фильтры — между различными стеками фреймворков. Кроме того, отсутствовали унифицированные интерфейсы для потоков данных, заголовков и других элементов HTTP-сообщений.
PSR-7 \cite{psr7standard} устранил эту фрагментацию, предложив стандартизированную модель HTTP-сообщений и чётко определённый набор интерфейсов для основных сущностей: \texttt{Request}, \texttt{Response}, \texttt{Stream}, \texttt{UploadedFile} и \texttt{URI}.
Практическим следствием стандарта стало развитие middleware-компонентов и переносимых HTTP-библиотек. В экосистеме утвердились нативные PSR-7-совместимые реализации, такие как Slim 3 \cite{slim3} и Zend Diactoros \cite{zenddiactoros}. Крупные фреймворки также адаптировались к новой реальности: Symfony внедрил специализированные PSR-7-бриджи \cite{symfonypsr7bridges}, а Laravel обеспечил совместимость через интеграционные слои \cite{laravelpsr7compatibility}.
Таким образом, PSR-7 \cite{psr7standard} не только решил проблему фрагментации HTTP-интерфейсов, но и заложил архитектурную основу для последующей стандартизации — в частности, для разработки контрактов \texttt{middleware} в PSR-15 \cite{psr15standard}.

% Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из наиболее значимых изменений за всё время развития экосистемы PHP-фреймворков.

% \subsubsection{Причины}

% До PSR-7:

% \begin{itemize}
%     \item Каждый фреймворк представлял HTTP-запрос/ответ по-своему.
%     \item Невозможно было переносить \texttt{middleware}.
%     \item Невозможно было использовать один и тот же HTTP-клиент или роутер между фреймворками.
%     \item Не существовало общего интерфейса потоков \texttt{streams}, \texttt{cookies}, \texttt{headers}.
% \end{itemize}

% \subsubsection{Принятое решение}

% PSR-7 создал единый интерфейс для:

% \begin{itemize}
%     \item \texttt{Request}.
%     \item \texttt{Response}.
%     \item \texttt{Stream}.
%     \item \texttt{UploadedFile}.
%     \item \texttt{URI}.
% \end{itemize}

% Это впервые позволило библиотекам работать независимо от фреймворка.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item Появление Slim 3 \cite{slim3}, Zend Diactoros \cite{zenddiactoros}, Guzzle PSR-7 clients \cite{guzzlepsr7clients}.
%     \item Появление кросс-фреймворковых \texttt{middleware}.
%     \item Symfony добавил PSR-7-бриджи \cite{symfonypsr7bridges}.
%     \item Laravel адаптировал совместимость на уровне интеграций \cite{laravelpsr7compatibility}.
% \end{itemize}

% PSR-7 \cite{psr7standard} стал фундаментом для PSR-15 \cite{psr15standard} и новой культуры \texttt{middleware} в PHP.
\subsubsection{PSR-11 и унификация DI-контейнеров (2017)}
Ещё одной существенной проблемой PHP-экосистемы до стандартизации являлась несовместимость контейнеров внедрения зависимостей: такие фреймворки, как Laravel, Symfony и Zend Framework, реализовывали собственные, взаимно несовместимые API, что не позволяло сторонним библиотекам запрашивать зависимости абстрактно и переносимо.
Принятие стандарта PSR-11 \cite{psr11standard} устранило данный барьер, определив спецификацию контейнера в виде двух интерфейсов: \texttt{ContainerInterface} и \texttt{NotFoundExceptionInterface}.
Благодаря этому сторонние компоненты получили возможность взаимодействовать с DI-контейнером без привязки к конкретному фреймворку. В результате внедрение зависимостей трансформировалось из внутреннего механизма отдельных фреймворков в общую экосистемную практику. Это способствовало снижению фрагментации пакетов и упростило разработку переносимых компонентов, совместимость которых обеспечивается исключительно соответствием требованиям PSR-11 \cite{psr11standard}.

% Ещё одной ключевой проблемой PHP-фреймворков была несовместимость контейнеров зависимостей.

% \subsubsection{Причины}

% До PSR-11:
% \begin{itemize}
%     \item Каждый фреймворк имел собственный DI.
%     \item Пакеты не могли объявлять зависимости абстрактно.
%     \item Невозможно было использовать библиотеку, требующую объект из контейнера другого фреймворка.
% \end{itemize}

% Контейнеры Laravel, Symfony, Zend имели разные API.

% \subsubsection{Принятое решение}

% PSR-11 ввёл два интерфейса:

% \begin{itemize}
%     \item \graybox{ContainerInterface}.
%     \item \graybox{NotFoundExceptionInterface}.
% \end{itemize}

% Разработчики библиотек получили способ запрашивать зависимости без привязки к конкретному фреймворку.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item DI стал общим архитектурным механизмом, а не «особенностью» конкретного фреймворка.
%     \item \graybox{Middleware}-компоненты стали переносимыми.
%     \item Снизилась фрагментация библиотек.
% \end{itemize}

% PSR-11 \cite{psr11standard} способствовал развитию переносимых компонентов и библиотек, которым требуется доступ к контейнеру зависимостей без привязки к конкретному фреймворку.

\subsubsection{PSR-15 и middleware-архитектура (2017–2018)}
После принятия стандарта PSR-7 \cite{psr7standard}, унифицировавшего представление HTTP-сообщений, стала возможной дальнейшая стандартизация самой модели обработки запросов через цепочки middleware.
До появления PSR-15 \cite{psr15standard} фреймворки применяли несовместимые подходы к организации middleware-слоя: так, Symfony использовал компонент HttpKernel, Laravel — собственные фильтры и middleware-механизмы, тогда как последовательная middleware-архитектура, основанная на цепочках обработчиков, была характерна лишь для отдельных стеков, таких как Slim \cite{slim4} и Zend Expressive (впоследствии Mezzio) \cite{zendexpressive}.
Стандарт PSR-15 \cite{psr15standard} формализовал два базовых интерфейса: \texttt{MiddlewareInterface} и \texttt{RequestHandlerInterface}.
Это приблизило PHP-экосистему к устоявшимся в других языках моделям обработки запросов через middleware-цепочки — таким как Rack (Ruby), WSGI (Python) и Connect/Express (Node.js).
Практическое значение PSR-15 \cite{psr15standard} заключалось в ускорении разработки переносимых middleware-компонентов и обеспечении единой основы для middleware-ориентированных фреймворков, включая Mezzio \cite{zendexpressive} и Slim 4 \cite{slim4}. Фреймворки с иной архитектурой, такие как Symfony и Laravel, сохранили свои внутренние модели, но обеспечили совместимость с PSR-15 посредством адаптеров и мостов \cite{symfonypsr7bridges, laravelpsr7compatibility}.
В результате \texttt{middleware} превратился в одну из ключевых архитектурных единиц проектирования современных PHP-приложений.

% После PSR-7 \cite{psr7standard} стало возможно стандартизировать поведение обработки запросов.
% Это позволило создать цепочки \texttt{middleware}.

% \subsubsection{Причины}

% Лишь некоторые фреймворки (Slim \cite{slim4}, Zend Expressive \cite{zendexpressive}) имели развитую \texttt{middleware}-модель.
% Symfony использовал HttpKernel, Laravel использовал фильтры и \texttt{middleware}, но их интерфейсы были несовместимы.

% \subsubsection{Принятое решение}

% PSR-15 \cite{psr15standard} определил:

% \begin{itemize}
%     \item \graybox{MiddlewareInterface}.
%     \item \graybox{RequestHandlerInterface}.
% \end{itemize}

% Это дало PHP ту же модель, что и:
% \begin{itemize}
%     \item Rack (Ruby).
%     \item WSGI (Python).
%     \item Connect (Node.js).
% \end{itemize}

% \subsubsection{Результаты}

% \begin{itemize}
%     \item Expressive / Mezzio (Zend → Laminas) стал первым PSR-15-first фреймворком \cite{zendexpressive}.
%     \item Slim 4 полностью перешёл на PSR-15 \cite{slim4}.
%     \item Symfony HttpKernel получил адаптеры \cite{symfonypsr7bridges}.
%     \item Laravel сохранил собственный контракт, но стал совместим через адаптеры \cite{laravelpsr7compatibility}.
% \end{itemize}

% Middleware стала центральной архитектурной единицей PHP-приложений.

\subsection{Влияние PHP 7 и PHP 8 на архитектуру фреймворков}

\subsubsection{PHP 7 (2015)}

\begin{itemize}
    \item Существенный прирост производительности по сравнению с PHP 5.x.
    \item Строгая модель ошибок (движение от предупреждений к исключениям).
    \item Scalar type hints, return types.
\end{itemize}

\subsubsection{PHP 8 (2020)}

\begin{itemize}
    \item Union types.
    \item Attributes.
    \item Match.
    \item JIT.
    \item Улучшенная типобезопасность.
\end{itemize}

\subsubsection{Результаты для фреймворков}

\begin{itemize}
    \item Symfony 3/4 \cite{symfonydependencyinjection} переписали DI-контейнер под строгую типизацию.
    \item Laravel \cite{laraveldocs} стал массово переходить к типизированным сигнатурам.
    \item Появилась культура строгих DTO, Value Objects, Immutable объектов.
    \item Фреймворки сократили магию и усилили контрактность API.
\end{itemize}

Типизация стала центральным архитектурным трендом 2020-х годов.

\subsection{Symfony: эволюция компонентной модели}

Symfony стал главным драйвером стандартизации.

\subsubsection{Основные изменения}

\begin{itemize}
    \item Переход от «полного фреймворка» к компонентам \cite{fabpot2012symfonycomponents} (HttpFoundation, EventDispatcher, Console, Routing).
    \item Адаптация архитектуры под PSR-7/PSR-11 \cite{symfonypsr7bridges, psr11standard}.
    \item Внедрение autowiring и автоконфигурации.
    \item Появление Symfony Flex как современного пакета приложений.
\end{itemize}
\subsubsection{Результаты}

Компонентная модель Symfony привела к тому, что многие проекты начали использовать отдельные компоненты Symfony как «строительные блоки» независимо от полного фреймворка. Это усилило тенденцию к стандартной инфраструктуре вне ядра языка: такие компоненты, как HttpKernel и EventDispatcher, стали де-факто архитектурными ориентирами для построения расширяемых приложений и библиотек, включая экосистему Laravel \cite{laraveldocs}.

\subsection{Laravel: эволюция DX и влияние стандартов}

Laravel \cite{laraveldocs} (2011) в 2015–2025 годах закрепился как фреймворк, ориентированный на удобство разработки (DX-first), единообразие API и практики convention over configuration, что сделало его особенно привлекательным для массовой разработки прикладных веб-систем.

В период 2015–2025:

\subsubsection{Основные изменения}

\begin{itemize}
    \item Переход на PSR-4, Composer и частично PSR-11.
    \item Внедрение middleware-модели совместимой с PSR-15.
    \item Адаптация к PHP 7/8 (типизация, атрибуты).
    \item Появление Horizon, Octane, Sail, Pint — инфраструктурных компонентов.
    \item Более строгая структура маршрутизации и DI.
\end{itemize}

\subsubsection{Результаты}

Laravel \cite{laraveldocs} стал «массовым воплощением» стандартизированной экосистемы PHP:

\begin{itemize}
    \item Он интегрирует PSR-совместимые библиотеки.
    \item Служит входной точкой для новых разработчиков.
    \item Влияет на индустриальные практики (DX, миграции, Eloquent как ORM-эталон).
\end{itemize}


\section{Отвергнутые и отложенные изменения}

Как и в случае с другими зрелыми технологиями, процесс стандартизации PHP-фреймворков сопровождался многочисленными предложениями, не вошедшими в финальные версии PSR-стандартов или отложенными на неопределённый срок.

Эти обсуждения позволяют понять, какие архитектурные решения были сочтены слишком узкими, слишком рискованными или концептуально несовместимыми с направлением развития экосистемы.

Ниже рассмотрены наиболее значимые инициативы, не приведшие к формированию стандарта.

\subsection{Несостоявшийся PSR для маршрутизации (Router PSR)}

Одним из регулярно поднимаемых предложений в рассылках PHP-FIG \cite{figrouterdiscussion} начиная с 2015 года было создание стандарта для роутинга HTTP-запросов.

\subsubsection{Причины появления инициативы}

Фреймворки использовали разные архитектуры маршрутов:

\begin{itemize}
    \item Laravel применяет декларативную синтаксическую модель (fluent API) \cite{laravelrouting}.
    \item Symfony использует аннотации, YAML и PHP-конфигурации \cite{symfonyrouting}.
    \item Slim и Mezzio строят маршрутизацию вокруг middleware \cite{slimrouting}.
    \item FastRoute — чисто функциональная библиотека без привязки к фреймворку \cite{fastroute}.
\end{itemize}

Отсутствие общего интерфейса приводило к невозможности создать:

\begin{itemize}
    \item Единый набор middleware для маршрутизации.
    \item Универсальные инструменты тестирования маршрутов.
    \item Переносимые роутинговые DSL.
\end{itemize}

\subsubsection{Причины отказа}
В обсуждениях FIG (2016–2018) было выявлено несколько проблем:

\subsubsection*{Различие моделей маршрутизации}
Одни фреймворки используют controller-based архитектуру (Laravel \cite{laravelrouting}, Symfony \cite{symfonyrouting}), другие (например Slim \cite{slimrouting}, Mezzio) используют middleware-based архитектуру.
Приведение этих моделей к единому интерфейсу оказалось практически невозможным.

\subsubsection*{Слишком высокий уровень абстракции}
Любой интерфейс становился либо:
\begin{itemize}
    \item Слишком низкоуровневым (и не решал задачи).
    \item Или слишком высоким.
\end{itemize}
\subsubsection*{Стандарт рисковал закрепить устаревший подход}
FIG избегает «Навязывать» архитектурные решения, чтобы не мешать инновациям.

\subsubsection*{Итог}
Инициатива была закрыта как слишком сложная и недостаточно универсальная.
Разработчики договорились, что роутинг останется частью каждого фреймворка, а интеграции будут строиться через PSR-7 \cite{psr7standard} и PSR-15 \cite{psr15standard}.

\subsection{Попытка создать PSR для ORM и абстракции работы с базами данных}

Регулярно обсуждалось создание стандарта для доступа к данным аналога JDBC для Java.
Попытки разработать единый интерфейс для ORM поднимались в рассылке PHP-FIG с 2014 по 2020 год \cite{figormdiscussion}.

\subsubsection*{Мотивация}

\begin{itemize}
    \item Множество несовместимых ORM: Doctrine ORM \cite{doctrineorm}, Eloquent ORM \cite{eloquentorm}, Propel \cite{propelorm}, RedBeanPHP \cite{redbeanphp}.
    \item Попытки создать стандартный QueryBuilder или EntityManager обсуждались с 2014 по 2020 год.
\end{itemize}


\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разные философии данных.
    \begin{itemize}
        \item Doctrine — ориентирована на DDD и Unit of Work.
        \item Eloquent — ActiveRecord и stateful-модель.
        \item Propel — XML-генерация моделей.
        \item RedBean — динамические схемы.
    \end{itemize}
    \item Разработчики ORM не готовы к унификации.\\
    Doctrine имеет строгую архитектуру, Laravel — гибкую, Eloquent использует «магические» свойства.
    \item Большая часть индустрии предпочитает свободу.\\
    FIG не хотел повторить опыт Java EE, где стандарты замедляли эволюцию ORM.
\end{itemize}

\subsubsection*{Итог}

PSR для ORM был признан нежизнеспособным.


\subsection{PSR-14 (Event Dispatcher): стандарт, который останется частичным}
PSR-14 \cite{psr14standard} был принят в 2019 году, но его разработка сопровождалась огромным количеством противоречий в рассылках PHP-FIG \cite{figpsr14discussion}.

\subsubsection*{Проблемы}
\begin{itemize}
    \item Фреймворки используют разные event models.
    \begin{itemize}
        \item Symfony: синхронный диспетчер событий, на основе объектных слушателей \cite{symfonyevents}.
        \item Laravel: разделение событий и слушателей + очередь + broadcast \cite{laravalevents}.
        \item Zend Framework: агрегаторы событий \cite{zendEventManager}.
    \end{itemize}
    Найти общую модель оказалось крайне трудно.
    \item Глубокие различия в семантике слушателей.\\
    Например, прекращение обработки событий отсутствует во многих системах.
    \item Слишком узкий охват стандарта.\\
    PSR-14 определяет слишком абстрактный интерфейс:
    \begin{lstlisting}[language=php]
    interface EventDispatcherInterface {
        public function dispatch(object $event): object;
    }
    \end{lstlisting}
\end{itemize}

\subsubsection*{Итог}
PSR-14 принят, но в экосистеме остаётся «вторичным» стандартом.
Существенная часть сообществ его игнорирует.

\subsection{Попытка создания PSR для валидаторов и форм}
Это обсуждение велось эпизодически с 2016 по 2021 годы \cite{figvalidationdiscussion}.

\subsubsection*{Мотивация}
\begin{itemize}
    \item Symfony Form + Validator имеют сложную, но зрелую модель \cite{symfonyform, symfonyvalidator}.
    \item Laravel Validation — декларативная модель со строковыми правилами \cite{laravelvalidation}.
    \item Respect/Validation — функциональная библиотека \cite{respectvalidation}.
\end{itemize}
Наличие множества несовместимых подходов порождало предложение создать переносимый стандарт.

\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разный уровень абстракции.
    \item Слишком разный DSL.\\
    Сравните:
    \begin{itemize}
        \item \graybox{'required|min:6'} (Laravel),
        \item \graybox{new Length(['min'=>6])} (Symfony),
        \item \graybox{v::stringType()->length(6)} (Respect).
    \end{itemize}
    \item Нежелание ограничивать инновации.\\
    Фреймворки активно экспериментируют со схемами данных.
\end{itemize}

\subsubsection*{Итог}
PSR для валидаторов и форм был признан нежизнеспособным.


\subsection{Споры вокруг PSR-18 (HTTP Client)}

PSR-18 \cite{psr18standard} был принят в 2019 году, но с серьёзными дискуссиями \cite{figpsr18discussion}.

\subsubsection*{Причины споров}

\begin{itemize}
    \item Разные модели ошибок (исключения vs error responses).
    \item Различия в реализации Guzzle \cite{guzzlehttp}, HTTPlug \cite{httplug}, Symfony HttpClient \cite{symfonyhttpclient}.
    \item Споры о синхронности vs асинхронности.
\end{itemize}

Некоторые разработчики хотели:

\begin{itemize}
    \item Асинхронный интерфейс (в стиле Promise).
    \item Unified Streaming API.
    \item Поддержку cancellation.
\end{itemize}

FIG решил ограничиться минимальным синхронным интерфейсом, что вызвало критику, но позволило стандартизировать общие ожидания.

\subsubsection*{Итог}

Стандарт был принят как «минимально необходимый», а остальные аспекты намеренно не стандартизированы.

\subsection{Предложение о расширении PSR-11 (унифицированная конфигурация контейнера)}

Иногда обсуждался стандарт для \cite{figpsr11expansion}:

\begin{itemize}
    \item Регистрации сервисов.
    \item Определения параметров.
    \item Описания factories.
\end{itemize}

Это сделало бы DI-контейнеры полностью совместимыми.

\subsubsection*{Причины отказа}

\begin{itemize}
    \item Разные модели конфигурации контейнера.
    \begin{itemize}
        \item Symfony использует YAML/PHP/XML \cite{symfonydependencyinjection}.
        \item Laravel использует bindings и closures \cite{laravelcontainer}.
        \item Laminas: Массивы-конфигурации \cite{laminasdi}.
    \end{itemize}
    Невозможно привести к общему знаменателю.
    \item Опасение закрепления устаревших подходов
    Стандартизация могла заморозить развитие DI.
\end{itemize}

\subsubsection*{Итог}
PSR-11 \cite{psr11standard} остался минималистичным.

\section{Заключение}

За период 2015–2025 годов экосистема PHP-фреймворков претерпела глубокую трансформацию, в результате которой веб-разработка на PHP фактически перешла от фрагментированного набора несовместимых архитектур к единому технологическому пространству, основанному на стандартах и переносимых компонентах.

Ключевую роль в этом процессе сыграли стандарты PHP-FIG (PSR-4, PSR-7, PSR-11, PSR-15), Composer и переход языка к строгой модели типизации в версиях PHP 7 и 8.

Эти изменения оказали системное влияние как на внутренние архитектуры фреймворков, так и на методологию разработки приложений.

Принятие PSR-4 и Composer стало отправной точкой для унификации структуры проектов, что позволило разрушить жёсткие границы между экосистемами разных фреймворков.

Стандартизация HTTP-модели (PSR-7) и middleware-контрактов (PSR-15) сформировала общий слой interoperability, дав толчок развитию кросс-фреймворковых библиотек и middleware-стека.

PSR-11 обеспечил совместимость контейнеров зависимостей, благодаря чему переносимость сервисов и компонентов значительно увеличилась.

Совокупно эти стандарты сформировали основу современной PHP-инфраструктуры, в которой логика приложения теперь отделена от конкретного фреймворка.


Наряду со стандартами FIG значительное влияние оказали изменения в самом языке: строгая типизация, исключительная модель ошибок, увеличение производительности PHP 7, а также атрибуты и JIT-компиляция в PHP 8.

Эти изменения стимулировали фреймворки к переработке внутренних механизмов и улучшению архитектурных практик.

Symfony в этот период окончательно утвердился как компонентный фреймворк, определяющий технические ориентиры для всей PHP-индустрии; Laravel, напротив, стал укреплять свою позицию как высокоуровневый фреймворк, фокусирующийся на удобстве разработки и интеграции с современными DevOps-практиками.

Современные версии обоих фреймворков демонстрируют высокую степень согласованности с PSR-стандартами и активно используют возможности нового PHP.


Особое значение имеют технологии и стандарты, которые не были приняты.

Несостоявшийся PSR для роутинга, отсутствие стандарта для ORM, частичная применимость PSR-14 — всё это демонстрирует, что стандартизация не может и не должна охватывать все аспекты PHP-экосистемы.

Слишком разнообразные архитектуры и различные философии разработки делают некоторые стандарты непрактичными.

В этом смысле отказ от стандартизации отдельных областей оказался не менее ценным, чем успешные инициативы: он позволил индустрии сохранить гибкость и конкурентное разнообразие.

В целом, архитектурная эволюция PHP-фреймворков в 2015–2025 годах может быть охарактеризована как движение к стандартизации на ключевых уровнях абстракции при сохранении свободы в реализации высокоуровневых концепций.

Этот период стал временем консолидации и зрелости: фреймворки перестали быть самостоятельными островами и стали частями единой экосистемы, в которой интерфейсы важнее реализаций, а архитектура — важнее конкретных технологий.

PHP, часто считавшийся устаревающим, за это десятилетие подтвердил свою жизнеспособность, адаптировавшись к современным требованиям производительности, типобезопасности и модульности.

Эта трансформация стала возможной благодаря открытому процессу разработки, публичным обсуждениям в PHP-FIG и активной роли сообществ Symfony и Laravel.

Таким образом, изменения 2015–2025 годов можно считать одним из самых успешных этапов в истории PHP: язык и его фреймворки не только сохранили позиции, но и стали примером того, как открытая стандартизация и согласованные архитектурные решения способны преобразовать зрелую технологию в соответствующую требованиям нового времени.
\setmonofont{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{programming_history}

\end{document}
