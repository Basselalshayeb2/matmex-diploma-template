% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macros see also
% https://tex.stackexchange.com/questions/78101/

% По умолчанию используется шрифт 14 размера.
% Если Вы не влезаете в лимит страниц и нужен 12-й шрифт,
% то уберите опцию [14pt]

\documentclass[14pt, russian]{matmex-diploma-custom}
\usepackage{listings}
\usepackage{xcolor}

\newcommand{\graybox}[1]{%
  \colorbox{lightgray}{\strut #1}%
}


\input{preamble.tex}

\begin{document}

\input{programming_history_title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\pagebreak

\section{Введение}
\thispagestyle{withCompileDate}
PHP традиционно играет важную роль в динамичном развитии веб-разработки в течение почти трех десятилетий.
Согласно актуальной статистике W3Techs\cite{W3Techs} по состоянию на 1 ноября 2025 года, PHP используется в 72.9\% всех веб-сайтов с известным серверным языком.

PHP\cite{phplatest} стал основой для многих систем управления контентом и прикладных веб-решений благодаря низкому порогу входа и широкой доступности хостинга.

Тем не менее, устойчивость языка и его экосистемы на протяжении столь длительного периода в значительной степени связана с развитием общих архитектурных практик и стандартов, которые определили индустрию PHP\cite{phplatest}-разработки.

В начале 2000-х годов появились первые PHP\cite{phplatest}-фреймворки. CakePHP (2005)\cite{cakephp2005announce}, Symfony (2005)\cite{symfony2005release} и CodeIgniter (2006)\cite{codeigniter2006announce} поставили основы MVC-подхода и организовали разработку веб-приложений без стандартов.

Тем не менее, по мере роста сложности веб-приложений стало очевидно, что архитектура 2000-х годов сталкивалась с важными ограничениями, такими как непрозрачная архитектура, несовместимость компонентов, отсутствие унифицированных интерфейсов и низкая тестируемость.

В течение следующих десяти лет (2005–2015) произошли значительные изменения в PHP\cite{phplatest}-стеке. Это было связано с разработкой PHP-FIG \cite{phpfig2009charter} и ряда стандартов PSR \cite{psr0standard}, появлением Composer \cite{seldaek2012composer}, унификацией HTTP-модели\cite{psr7standard}, распространением принципов DI \cite{psr11standard} и архитектурой middleware \cite{psr15standard}.

Тем не менее, между 2015 и 2025 годами произошли наиболее значительные структурные изменения в PHP\cite{phplatest}-фреймворке. Эти изменения радикально изменили архитектурные решения, принципы проектирования и практики масштабирования.

Эти изменения включали выход PHP 7\cite{php7rfc2015}, массовую типизацию и строгую модель ошибок, переход Symfony на компонентный подход, стремительный рост Laravel, падение Zend Framework и его перерождение в Laminas.

Цель этой работы состоит в том, чтобы проанализировать основные архитектурные и технологические изменения в PHP\cite{phplatest}-фреймворках за 2015–2025 годы, определить причины этих изменений, оценить эффективность принятых решений и определить, какие идеи были отвергнуты или изменились в ходе обсуждений.
В анализе используются материалы рассылок PHP-FIG\cite{phpfig2009charter}, предложения RFC Internals PHP, официальные публикации Symfony\cite{symfony2005release} и Laravel\cite{laravel2011announce}, дискуссии GitHub о стандартах Composer и PSR, а также выступления разработчиков на конференциях, таких как SymfonyCon\cite{symfonycon} и Laracon\cite{laracon}.

Таким образом, в статье рассматривается не только развитие определенных фреймворков, но и более широкий процесс создания профессиональной экосистемы PHP, в которой технологические решения являются основной движущей силой прогресса.


\section{Предпосылки: фрагментированная экосистема PHP до 2015 года и необходимость стандартизации}
К 2015 году промышленная разработка PHP\cite{phplatest} началась с противоречий.

С другой стороны, благодаря своей простоте развёртывания и широкой совместимости PHP\cite{phplatest} продолжал доминировать в веб-разработке.

Напротив, экосистема испытывала значительные архитектурные ограничения из-за отсутствия единых правил и несовместимости основных компонентов фреймворка.

Эти ограничения замедлили язык и фреймворки.

\subsection{Отсутствие единых интерфейсов и высокая фрагментация}

До того, как в экосистеме PHP появилась PHP-FIG\cite{phpfig2009charter}, не существовало общепризнанных соглашений по:

\begin{itemize}
    \item Система каталогов.
    \item Автоматическая загрузка классов.
    \item Форматы запросов и ответов HTTP.
    \item Интерфейсы контейнеров, которые зависят от зависимостей.
    \item Методы middleware.
\end{itemize}

Каждый фреймворк, включая Symfony\cite{symfony2005release}, Zend Framework\cite{zendframework2006announce}, CakePHP\cite{cakephp2005announce} и CodeIgniter\cite{codeigniter2006announce}, разработал свои собственные решения, которые часто не пересекались.

Что привело к эффекту «изолированных островов» в PHP-мире, заключалось в том, что библиотеки и инструменты не могли быть повторно использованы между проектами.

Например:

\begin{itemize}
    \item Symfony\cite{symfony2005release} использовал собственный автозагрузчик и собственные соглашения об именовании классов.
    \item Zend Framework\cite{zendframework2006announce} применял иной подход к структуре каталогов.
    \item Многие библиотеки требовали ручного подключения файлов и не имели механизма декларирования зависимостей.
\end{itemize}

Это создавало тесную связность между фреймворком и компонентами.
Интеграции часто строились на неформализованных паттернах, а меняющиеся детали реализации ломали совместимость.

\subsection{Проблема совместимости и отсутствие переиспользуемых компонентов}

Ключевой проблемой периода до 2012–2014 годов была невозможность использовать одну и ту же библиотеку в разных фреймворках.

Например, HTTP-клиенты, логгеры и шаблонизаторы были жестко «привязаны» к конкретному фреймворку, а попытки переносить решения приводили к конфликтам стилей, соглашений и точек расширения.

Symfony\cite{symfony2005release} первым попытался решить эту проблему, выделив «компонентный подход\cite{fabpot2012symfonycomponents}» (начиная с Symfony 2\cite{symfony2011release}), но без стандартизации на уровне индустрии это был лишь частичный шаг.

Разработчики других фреймворков могли использовать компоненты Symfony, но не было гарантий совместимости.


\subsection{Отсутствие стандартизированной модели HTTP}

Одним из главных технологических ограничений было отсутствие стандартизированного представления:

\begin{itemize}
    \item HTTP-запроса.
    \item HTTP-ответа.
    \item Атрибутов, заголовков, стримов.
\end{itemize}

Каждый фреймворк определял собственные классы:

\begin{itemize}
    \item Symfony HttpFoundation \cite{symfonyhttpfoundation}.
    \item Zend\\Http \cite{zendhttp} (Request / Response).
    \item Slim\\Http \cite{slimhttp}.
    \item Собственные реализации в CakePHP \cite{cakephphttp}.
\end{itemize}

Это делало невозможным:

\begin{itemize}
    \item Взаимозаменяемые middleware.
    \item Стандартные фильтры и обработчики.
    \item Переносимость кода между фреймворками.
    \item Унифицированные HTTP-клиенты.
\end{itemize}

Проблема была настолько глубокой, что в рассылке FIG обсуждение PSR-7\cite{psr7standard} длилось почти 3 года.
Это ещё один признак того, насколько фундаментальной была задача стандартизации.


\subsection{Отсутствие единых правил автозагрузки и зависимостей}

До релиза Composer \cite{seldaek2012composer} (2012) и PSR-4 \cite{psr4standard} (2013–2014):

\begin{itemize}
    \item Большинство библиотек подключались вручную через \texttt{require} или \texttt{include}.
    \item Не было декларативного управления зависимостями.
    \item Поставка кода происходила через ZIP-архивы или PEAR (который плохо поддерживался и был неинтуитивен).
\end{itemize}

\texttt{Autoloading} был одной из самых болезненных частей PHP-разработки:

\begin{itemize}
    \item Фреймворки требовали строгих соглашений по структуре каталогов.
    \item Библиотеки не могли легко объявлять свои зависимости.
    \item Конфликты версий были обычным делом.
\end{itemize}

Composer \cite{seldaek2012composer} радикально изменил эту ситуацию, но его широкое принятие началось только после 2014–2015 — и именно этот период стал отправной точкой изменений, анализируемых далее.

\subsection{Проблемы тестируемости и внедрения зависимостей}
До принятия PSR-11 \cite{psr11standard} (Container Interface) каждый фреймворк реализовывал собственный DI-контейнер, и ни один из них не был совместим с другим:

\begin{itemize}
    \item Symfony DependencyInjection \cite{symfonydependencyinjection}.
    \item Laravel Container \cite{laravelcontainer}.
    \item Zend\\ServiceManager \cite{zendservicemanager}.
    \item Pimple \cite{pimple}.
\end{itemize}

Отсутствие общего интерфейса:

\begin{itemize}
    \item Усложняло создание многоразовых пакетов.
    \item Делало невозможным перенос middleware-компонентов.
    \item Тормозило развитие архитектур, основанных на инверсии управления.
\end{itemize}

Архитектура DI\footnote{
    \textbf{DI — Dependency Injection}.
    Внедрение зависимостей: объект получает свои зависимости извне, а не создаёт их самостоятельно.
    } была одной из ключевых болевых точек, которую индустрия смогла решить только в последние 10 лет (2015–2025), в ходе стандартизации PSR-11 \cite{psr11standard}.


\section{Развитие стандартов и архитектурных решений в экосистеме PHP (2015–2025)}

Период 2015–2025 годов стал для PHP-фреймворков временем глубокой технологической перестройки.

На протяжении предыдущего десятилетия (2005–2015) были заложены фундаментальные идеи: создание PHP-FIG \cite{phpfig2009charter}, появление Composer \cite{seldaek2012composer}, формирование первых PSR-стандартов \cite{psr0standard}, PSR-4 \cite{psr4standard}, PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard}.

Однако именно после выхода PHP 7 \cite{php7rfc2015} и широкого принятия PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard} начался качественный переход к современной архитектуре веб-приложений.

В этом разделе анализируются ключевые архитектурные изменения, причины их появления и влияние на экосистему.

\subsection{Composer как основа модернизации экосистемы (2015–2025)}
Хотя Composer \cite{seldaek2012composer} был выпущен в 2012 году, его массовое принятие произошло в период 2015–2017 годов.

Именно в это время большинство фреймворков и библиотек окончательно перешли на декларативное управление зависимостями.

\subsubsection{Причины изменения:}
До Composer \cite{seldaek2012composer} управление зависимостями основывалось на:
\begin{itemize}
    \item Ручном подключении файлов через \texttt{require} или \texttt{include}.
    \item Распространении пакетов через \texttt{ZIP}-архивы или \texttt{PEAR}.
    \item Отсутствии разрешения конфликтов версий.
\end{itemize}

Это приводило к «зависимостному аду» \cite{dependencyHellWikipedia} и мешало развитию фреймворков.

\subsubsection{Принятое решение}

Composer \cite{seldaek2012composer} ввёл:

\begin{itemize}
    \item файл \texttt{composer.json} \cite{composerJsonSchema} в качестве декларации зависимостей.
    \item Автозагрузчик, основанный на PSR-4 \cite{psr4standard}.
    \item Семантическое версионирование \cite{semver}.
    \item Центральный репозиторий \texttt{Packagist} \cite{packagist}.
\end{itemize}

Философия Composer \cite{seldaek2012composer} повлияла на всю экосистему: фреймворки стали не «монолитами», а наборами компонентов, которые можно выбирать, комбинировать и обновлять независимо.


\subsubsection{Результаты}
\begin{itemize}
    \item Исчезла жёсткая привязка библиотек к конкретным фреймворкам.
    \item Появилось огромное количество независимых пакетов.
    \item Разработчики получили прозрачное управление зависимостями.
\end{itemize}
Composer \cite{seldaek2012composer} стал фактическим стандартом и сделал возможным внедрение последующих PSR.

\subsubsection{PSR-4 и единая модель автозагрузки}
PSR-4 \cite{psr4standard} (2014) стал ключевым переходом от хаотичных соглашений к единообразной системе.

Но именно в период 2015–2020, когда фреймворки начали массово переписывать внутренние структуры под PSR-4 \cite{psr4standard}.

\subsubsection{Причины}
До PSR-4 \cite{psr4standard}:
\begin{itemize}
    \item Каждый фреймворк имел собственные правила размещения классов.
    \item Не было единообразных пространств имён.
    \item Библиотеки не могли интегрироваться между собой.
\end{itemize}


\subsubsection{Принятое решение}
PSR-4 \cite{psr4standard} определил:
\begin{itemize}
    \item Строгие правила сопоставления пространств имён с каталогами.
    \item Автоматическую загрузку классов без ручных \texttt{include} или \texttt{require}.
\end{itemize}

\subsubsection{Результаты}
\begin{itemize}
    \item Библиотеки стали взаимозаменяемыми.
    \item Фреймворки уменьшили собственный «клей» и стали ориентироваться на компоненты.
    \item Composer \cite{seldaek2012composer} получил техническую основу для генерации стандартизированного автозагрузчика.
\end{itemize}

PSR-4 \cite{psr4standard} стал первым шагом к «общему грамматическому строю» всей экосистемы.


\subsection{PSR-7 и стандартизация HTTP-модели (2015)}

PSR-7 \cite{psr7standard} (HTTP Message Interface).

Это одно из самых значимых изменений за всё существование PHP-фреймворков.

\subsubsection{Причины}

До PSR-7:

\begin{itemize}
    \item Каждый фреймворк представлял HTTP-запрос/ответ по-своему.
    \item Невозможно было переносить \texttt{middleware}.
    \item Невозможно было использовать один и тот же HTTP-клиент или роутер между фреймворками.
    \item Не существовало общего интерфейса потоков \texttt{streams}, \texttt{cookies}, \texttt{headers}.
\end{itemize}

\subsubsection{Принятое решение}

PSR-7 создал единый интерфейс для:

\begin{itemize}
    \item \texttt{Request}.
    \item \texttt{Response}.
    \item \texttt{Stream}.
    \item \texttt{UploadedFile}.
    \item \texttt{URI}.
\end{itemize}

Это впервые позволило библиотекам работать независимо от фреймворка.

\subsubsection{Результаты}

\begin{itemize}
    \item Появление Slim 3 \cite{slim3}, Zend Diactoros \cite{zenddiactoros}, Guzzle PSR-7 clients \cite{guzzlepsr7clients}.
    \item Появление кросс-фреймворковых \texttt{middleware}.
    \item Symfony добавил PSR-7-бриджи \cite{symfonypsr7bridges}.
    \item Laravel адаптировал совместимость на уровне интеграций \cite{laravelpsr7compatibility}.
\end{itemize}

PSR-7 \cite{psr7standard} стал фундаментом для PSR-15 \cite{psr15standard} и новой культуры \texttt{middleware} в PHP.

\subsection{PSR-11 и унификация DI-контейнеров (2017)}

Ещё одной ключевой проблемой PHP-фреймворков была несовместимость контейнеров зависимостей.

\subsubsection{Причины}

До PSR-11:
\begin{itemize}
    \item Каждый фреймворк имел собственный DI.
    \item Пакеты не могли объявлять зависимости абстрактно.
    \item Невозможно было использовать библиотеку, требующую объект из контейнера другого фреймворка.
\end{itemize}

Контейнеры Laravel, Symfony, Zend имели разные API.

\subsubsection{Принятое решение}

PSR-11 ввёл два интерфейса:

\begin{itemize}
    \item \graybox{ContainerInterface}.
    \item \graybox{NotFoundExceptionInterface}.
\end{itemize}

Разработчики библиотек получили способ запрашивать зависимости без привязки к конкретному фреймворку.

\subsubsection{Результаты}

\begin{itemize}
    \item DI стал общим архитектурным механизмом, а не «особенностью» конкретного фреймворка.
    \item \graybox{Middleware}-компоненты стали переносимыми.
    \item Снизилась фрагментация библиотек.
\end{itemize}

PSR-11 \cite{psr11standard} стал фундаментом для PSR-15 \cite{psr15standard} и новой культуры \texttt{middleware} в PHP.

\subsection{PSR-15 и middleware-архитектура (2017–2018)}

После PSR-7 \cite{psr7standard} стало возможно стандартизировать поведение обработки запросов.
Это позволило создать цепочки \texttt{middleware}.

\subsubsection{Причины}

Лишь некоторые фреймворки (Slim \cite{slim4}, Zend Expressive \cite{zendexpressive}) имели развитую \texttt{middleware}-модель.
Symfony использовал HttpKernel, Laravel использовал фильтры и \texttt{middleware}, но их интерфейсы были несовместимы.

\subsubsection{Принятое решение}

PSR-15 \cite{psr15standard} определил:

\begin{itemize}
    \item \graybox{MiddlewareInterface}.
    \item \graybox{RequestHandlerInterface}.
\end{itemize}

Это дало PHP ту же модель, что и:
\begin{itemize}
    \item Rack (Ruby).
    \item WSGI (Python).
    \item Connect (Node.js).
\end{itemize}

\subsubsection{Результаты}

\begin{itemize}
    \item Expressive / Mezzio (Zend → Laminas) стал первым PSR-15-first фреймворком \cite{zendexpressive}.
    \item Slim 4 полностью перешёл на PSR-15 \cite{slim4}.
    \item Symfony HttpKernel получил адаптеры \cite{symfonypsr15bridge}.
    \item Laravel сохранил собственный контракт, но стал совместим через адаптеры \cite{laravelpsr7compatibility}.
\end{itemize}

Middleware стала центральной архитектурной единицей PHP-приложений.

\subsection{Влияние PHP 7 и PHP 8 на архитектуру фреймворков}

\subsubsection{PHP 7 (2015)}

\begin{itemize}
    \item Увеличение производительности в 2–3 раза.
    \item Строгая модель ошибок (движение от предупреждений к исключениям).
    \item Scalar type hints, return types.
\end{itemize}

\subsubsection{PHP 8 (2020)}

\begin{itemize}
    \item Union types.
    \item Attributes.
    \item Match.
    \item JIT.
    \item Улучшенная типобезопасность.
\end{itemize}

\subsubsection{Результаты для фреймворков}

\begin{itemize}
    \item Symfony 3/4 \cite{symfonydependencyinjection} переписали DI-контейнер под строгую типизацию.
    \item Laravel \cite{laraveldocs} стал массово переходить к типизированным сигнатурам.
    \item Появилась культура строгих DTO, Value Objects, Immutable объектов.
    \item Фреймворки сократили магию и усилили контрактность API.
\end{itemize}

Типизация стала центральным архитектурным трендом 2020-х годов.

\subsection{Symfony: эволюция компонентной модели}

Symfony стал главным драйвером стандартизации.

\subsubsection{Основные изменения}

\begin{itemize}
    \item Переход от «полного фреймворка» к компонентам \cite{fabpot2012symfonycomponents} (HttpFoundation, EventDispatcher, Console, Routing).
    \item Адаптация архитектуры под PSR-7/PSR-11 \cite{symfonypsr7bridges, psr11standard}.
    \item Внедрение autowiring и автоконфигурации.
    \item Появление Symfony Flex как современного пакета приложений.
\end{itemize}
\subsubsection{Результаты}

Большинство фреймворков (включая Laravel \cite{laraveldocs}) стали использовать компоненты Symfony либо идеологию Symfony:

\begin{itemize}
    \item HttpKernel → архитектурный эталон.
    \item EventDispatcher → основа для гибких систем расширения.
\end{itemize}

Symfony стал «стандартной библиотекой» для PHP вне ядра языка.



\subsection{Laravel: эволюция DX и влияние стандартов}

Laravel \cite{laraveldocs} (2011) стал главным популяризатором:

\begin{itemize}
    \item Единообразных API.
    \item Конвенций.
    \item Быстрой разработки (DX-first).
\end{itemize}

В период 2015–2025:

\subsubsection{Основные изменения}

\begin{itemize}
    \item Переход на PSR-4, Composer и частично PSR-11.
    \item Внедрение middleware-модели совместимой с PSR-15.
    \item Адаптация к PHP 7/8 (типизация, атрибуты).
    \item Появление Horizon, Octane, Sail, Pint — инфраструктурных компонентов.
    \item Более строгая структура маршрутизации и DI.
\end{itemize}

\subsubsection{Результаты}

Laravel \cite{laraveldocs} стал «массовым воплощением» стандартизированной экосистемы PHP:

\begin{itemize}
    \item Он интегрирует PSR-совместимые библиотеки.
    \item Служит входной точкой для новых разработчиков.
    \item Влияет на индустриальные практики (DX, миграции, Eloquent как ORM-эталон).
\end{itemize}


\section{Отвергнутые и отложенные изменения}

Как и в случае с другими зрелыми технологиями, процесс стандартизации PHP-фреймворков сопровождался многочисленными предложениями, не вошедшими в финальные версии PSR-стандартов или отложенными на неопределённый срок.

Эти обсуждения позволяют понять, какие архитектурные решения были сочтены слишком узкими, слишком рискованными или концептуально несовместимыми с направлением развития экосистемы.

Ниже рассмотрены наиболее значимые инициативы, не приведшие к формированию стандарта.

\subsection{Несостоявшийся PSR для маршрутизации (Router PSR)}

Одним из регулярно поднимаемых предложений в рассылках PHP-FIG \cite{figrouterdiscussion} начиная с 2015 года было создание стандарта для роутинга HTTP-запросов.

\subsubsection{Причины появления инициативы}

Фреймворки использовали разные архитектуры маршрутов:

\begin{itemize}
    \item Laravel применяет декларативную синтаксическую модель (fluent API) \cite{laravelrouting}.
    \item Symfony использует аннотации, YAML и PHP-конфигурации \cite{symfonyrouting}.
    \item Slim и Mezzio строят маршрутизацию вокруг middleware \cite{slimrouting}.
    \item FastRoute — чисто функциональная библиотека без привязки к фреймворку \cite{fastroute}.
\end{itemize}

Отсутствие общего интерфейса приводило к невозможности создать:

\begin{itemize}
    \item Единый набор middleware для маршрутизации.
    \item Универсальные инструменты тестирования маршрутов.
    \item Переносимые роутинговые DSL.
\end{itemize}

\subsubsection{Причины отказа}
В обсуждениях FIG (2016–2018) было выявлено несколько проблем:

\subsubsection*{Различие моделей маршрутизации}
Одни фреймворки используют controller-based архитектуру (Laravel \cite{laravelrouting}, Symfony \cite{symfonyrouting}), другие (например Slim \cite{slimrouting}, Mezzio) используют middleware-based архитектуру.
Приведение этих моделей к единому интерфейсу оказалось практически невозможным.

\subsubsection*{Слишком высокий уровень абстракции}
Любой интерфейс становился либо:
\begin{itemize}
    \item Слишком низкоуровневым (и не решал задачи).
    \item Или слишком высоким.
\end{itemize}
\subsubsection*{Стандарт рисковал закрепить устаревший подход}
FIG избегает «Навязывать» архитектурные решения, чтобы не мешать инновациям.

\subsubsection*{Итог}
Инициатива была закрыта как слишком сложная и недостаточно универсальная.
Разработчики договорились, что роутинг останется частью каждого фреймворка, а интеграции будут строиться через PSR-7 \cite{psr7standard} и PSR-15 \cite{psr15standard}.

\subsection{Попытка создать PSR для ORM и абстракции работы с базами данных}

Регулярно обсуждалось создание стандарта для доступа к данным аналога JDBC для Java.
Попытки разработать единый интерфейс для ORM поднимались в рассылке PHP-FIG с 2014 по 2020 год \cite{figormdiscussion}.

\subsubsection*{Мотивация}

\begin{itemize}
    \item Множество несовместимых ORM: Doctrine ORM \cite{doctrineorm}, Eloquent ORM \cite{eloquentorm}, Propel \cite{propelorm}, RedBeanPHP \cite{redbeanphp}.
    \item Попытки создать стандартный QueryBuilder или EntityManager обсуждались с 2014 по 2020 год.
\end{itemize}


\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разные философии данных.
    \begin{itemize}
        \item Doctrine — ориентирована на DDD и Unit of Work.
        \item Eloquent — ActiveRecord и stateful-модель.
        \item Propel — XML-генерация моделей.
        \item RedBean — динамические схемы.
    \end{itemize}
    \item Разработчики ORM не готовы к унификации.\\
    Doctrine имеет строгую архитектуру, Laravel — гибкую, Eloquent использует «магические» свойства.
    \item Большая часть индустрии предпочитает свободу.\\
    FIG не хотел повторить опыт Java EE, где стандарты замедляли эволюцию ORM.
\end{itemize}

\subsubsection*{Итог}

PSR для ORM был признан нежизнеспособным.


\subsection{PSR-14 (Event Dispatcher): стандарт, который останется частичным}
PSR-14 \cite{psr14standard} был принят в 2019 году, но его разработка сопровождалась огромным количеством противоречий в рассылках PHP-FIG \cite{figpsr14discussion}.

\subsubsection*{Проблемы}
\begin{itemize}
    \item Фреймворки используют разные event models.
    \begin{itemize}
        \item Symfony: синхронный диспетчер событий, на основе объектных слушателей \cite{symfonyevents}.
        \item Laravel: разделение событий и слушателей + очередь + broadcast \cite{laravalevents}.
        \item Zend Framework: агрегаторы событий \cite{zendEventManager}.
    \end{itemize}
    Найти общую модель оказалось крайне трудно.
    \item Глубокие различия в семантике слушателей.\\
    Например, прекращение обработки событий отсутствует во многих системах.
    \item Слишком узкий охват стандарта.\\
    PSR-14 определяет слишком абстрактный интерфейс:
    \begin{lstlisting}[language=php]
    interface EventDispatcherInterface {
        public function dispatch(object $event): object;
    }
    \end{lstlisting}
\end{itemize}

\subsubsection*{Итог}
PSR-14 принят, но в экосистеме остаётся «вторичным» стандартом.
Существенная часть сообществ его игнорирует.

\subsection{Попытка создания PSR для валидаторов и форм}
Это обсуждение велось эпизодически с 2016 по 2021 годы \cite{figvalidationdiscussion}.

\subsubsection*{Мотивация}
\begin{itemize}
    \item Symfony Form + Validator имеют сложную, но зрелую модель \cite{symfonyform, symfonyvalidator}.
    \item Laravel Validation — декларативная модель со строковыми правилами \cite{laravelvalidation}.
    \item Respect/Validation — функциональная библиотека \cite{respectvalidation}.
\end{itemize}
Наличие множества несовместимых подходов порождало предложение создать переносимый стандарт.

\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разный уровень абстракции.
    \item Слишком разный DSL.\\
    Сравните:
    \begin{itemize}
        \item \graybox{'required|min:6'} (Laravel),
        \item \graybox{new Length(['min'=>6])} (Symfony),
        \item \graybox{v::stringType()->length(6)} (Respect).
    \end{itemize}
    \item Нежелание ограничивать инновации.\\
    Фреймворки активно экспериментируют со схемами данных.
\end{itemize}

\subsubsection*{Итог}
PSR для валидаторов и форм был признан нежизнеспособным.


\subsection{Споры вокруг PSR-18 (HTTP Client)}

PSR-18 \cite{psr18standard} был принят в 2019 году, но с серьёзными дискуссиями \cite{figpsr18discussion}.

\subsubsection*{Причины споров}

\begin{itemize}
    \item Разные модели ошибок (исключения vs error responses).
    \item Различия в реализации Guzzle \cite{guzzlehttp}, HTTPlug \cite{httplug}, Symfony HttpClient \cite{symfonyhttpclient}.
    \item Споры о синхронности vs асинхронности.
\end{itemize}

Некоторые разработчики хотели:

\begin{itemize}
    \item Асинхронный интерфейс (в стиле Promise).
    \item Unified Streaming API.
    \item Поддержку cancellation.
\end{itemize}

FIG решил ограничиться минимальным синхронным интерфейсом, что вызвало критику, но позволило стандартизировать общие ожидания.

\subsubsection*{Итог}

Стандарт принят как «минимальный необходимый», остальные аспекты deliberately не стандартизированы.

\subsection{Предложение о расширении PSR-11 (унифицированная конфигурация контейнера)}

Иногда обсуждался стандарт для \cite{figpsr11expansion}:

\begin{itemize}
    \item Регистрации сервисов.
    \item Определения параметров.
    \item Описания factories.
\end{itemize}

Это сделало бы DI-контейнеры полностью совместимыми.

\subsubsection*{Причины отказа}

\begin{itemize}
    \item Разные модели конфигурации контейнера.
    \begin{itemize}
        \item Symfony использует YAML/PHP/XML \cite{symfonydependencyinjection}.
        \item Laravel использует bindings и closures \cite{laravelcontainer}.
        \item Laminas: Массивы-конфигурации \cite{laminasdi}.
    \end{itemize}
    Невозможно привести к общему знаменателю.
    \item Опасение закрепления устаревших подходов
    Стандартизация могла заморозить развитие DI.
\end{itemize}

\subsubsection*{Итог}
PSR-11 \cite{psr11standard} остался минималистичным.

\setmonofont{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{programming_history}

\end{document}
