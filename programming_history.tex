% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macros see also
% https://tex.stackexchange.com/questions/78101/

% По умолчанию используется шрифт 14 размера.
% Если Вы не влезаете в лимит страниц и нужен 12-й шрифт,
% то уберите опцию [14pt]

\documentclass[14pt, russian]{matmex-diploma-custom}
\usepackage{listings}
\usepackage{xcolor}

\newcommand{\graybox}[1]{%
  \colorbox{lightgray}{\strut #1}%
}


\input{preamble.tex}

\begin{document}

\input{programming_history_title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\pagebreak

\section{Введение}
\thispagestyle{withCompileDate}
PHP играет важную роль в веб-разработке на протяжении почти трёх десятилетий, оставаясь одним из наиболее распространённых серверных языков.

Согласно статистике W3Techs по состоянию на 1 ноября 2025 года, PHP используется в 72.9\% веб-сайтов с определённым языком серверной части \cite{W3Techs}.

Широкая доступность хостинга и относительно низкий порог входа сделали PHP \cite{phplatest} основой для множества систем управления контентом и прикладных веб-решений.

Однако, устойчивость языка и его экосистемы на протяжении длительного периода в значительной степени связана с развитием общих архитектурных практик и стандартов, которые определили индустрию PHP \cite{phplatest}-разработки.

В начале 2000-х годов в ответ на растущую сложность веб-приложений начали формироваться первые полнофункциональные PHP-фреймворки.

CakePHP (2005) \cite{cakephp2005announce}, Symfony (2005) \cite{symfony2005release} и CodeIgniter (2006) \cite{codeigniter2006announce} заложили основы MVC-подхода и упорядочили разработку веб-приложений в условиях отсутствия единых стандартов.

Однако по мере усложнения проектов стало очевидно, что решения того периода сталкиваются с рядом системных ограничений, включая непрозрачную архитектуру, несовместимость компонентов, отсутствие унифицированных интерфейсов и недостаточную тестируемость.

В течение следующего десятилетия (2005–2015) PHP \cite{phplatest}-стек претерпел значительные изменения. Это было связано с разработкой PHP-FIG \cite{phpfig2009charter} и ряда стандартов PSR \cite{psr0standard}, появлением Composer \cite{seldaek2012composer}, унификацией HTTP-модели \cite{psr7standard}, распространением принципов DI \cite{psr11standard} и архитектурой middleware \cite{psr15standard}.

Тем не менее, между 2015 и 2025 годами произошли наиболее значительные структурные изменения в PHP-фреймворках. Эти изменения радикально изменили архитектурные решения, принципы проектирования и практики масштабирования.

Эти преобразования охватывали выход PHP 7 \cite{php7rfc2015}, внедрение массовой типизации и переход к строгой модели обработки ошибок, реорганизацию Symfony \cite{symfony2005release} в рамках компонентной архитектуры, стремительный развитие Laravel \cite{laravel2011announce}, а также упадок Zend \cite{zendframework2006announce} Framework и его последующую трансформацию в проект Laminas.

Цель настоящей работы — провести комплексный анализ ключевых архитектурных и технологических изменений, произошедших в PHP-фреймворках в период с 2015 по 2025 годы. В рамках исследования предполагается выявить причины указанных изменений, оценить эффективность принятых техническиатурных решений, а также определить, какие концепции и подходы были отвергнуты или модифицированы в ходе профессиональных дискуссий.

Для достижения поставленных целей используются следующие источники: материалы рассылок PHP-FIG \cite{phpfig2009charter}, предложения RFC Internals PHP, официальные публикации Symfony \cite{symfony2005release} и Laravel \cite{laravel2011announce}, дискуссии GitHub о стандартах Composer и PSR, а также доклады разработчиков, представленные на профильных конференциях — в частности, SymfonyCon \cite{symfonycon} и Laracon \cite{laracon}.

Таким образом, в статье рассматривается не только эволюция отдельных фреймворков, но и более широкий процесс формирования профессиональной PHP-экосистемы, в которой технологические инновации выступают в качестве ключевого фактора развития.

\section{Особенности развития PHP-экосистемы до стандартизации (до 2015 года)}

К 2015 году промышленная разработка на PHP \cite{phplatest} характеризовалась двойственным положением. С одной стороны, язык сохранял широкое распространение и технологическую зрелость как платформа для веб-приложений, обусловленную простотой развёртывания, высокой доступностью хостинговых решений и устойчивой обратной совместимостью. С другой стороны, PHP-экосистема страдала от существенных архитектурных ограничений, вызванных отсутствием унифицированных стандартов проектирования и низкой совместимостью между ключевыми компонентами. Это приводило к увеличению совокупной стоимости сопровождения проектов, а также замедляло темпы развития как сторонних библиотек, так и фреймворков.
\subsection{Отсутствие единых интерфейсов}
До появления PHP-FIG \cite{phpfig2009charter} в экосистеме PHP отсутствовали общепринятые технические соглашения по ключевым аспектам разработки, включая:

\begin{itemize}
    \item организацию структуры каталогов;
    \item механизмы автоматической загрузки классов;
    \item унифицированное представление HTTP-запросов и ответов;
    \item интерфейсы контейнеров внедрения зависимостей (DI);
    \item стандартные контракты для middleware и модель обработки HTTP-запросов.
\end{itemize}

В результате каждый из ведущих фреймворков, включая Symfony \cite{symfony2005release}, Zend \cite{zendframework2006announce}, CakePHP \cite{cakephp2005announce} и CodeIgniter \cite{codeigniter2006announce}, реализовывал собственные, зачастую несовместимые подходы к решению этих задач. Это привело к эффекту фрагментации экосистемы PHP, при котором фреймворки и библиотеки развивались как изолированные подсистемы с ограниченной совместимостью.

Например, Symfony \cite{symfony2005release} применял собственный автозагрузчик и строгие соглашения об именовании, тогда как Zend предлагал иную структуру каталогов. Многие сторонние библиотеки того времени подключались вручную и не содержали формализованных метаданных о зависимостях, что исключало автоматизированное управление ими.

Такая ситуация приводила к высокой степени связанности между фреймворками и их компонентами. Интеграционные решения часто основывались на неформализованных соглашениях и паттернах, а изменения в деталях реализации нарушали обратную совместимость.

\subsection{Проблема совместимости и отсутствие компонентов повторного использования}

Ключевая проблема данного периода заключалась в невозможности использовать одну и ту же библиотеку в разных фреймворках. Такие распространённые компоненты, как HTTP-клиенты, инструменты логгирования и шаблонизаторы, были тесно интегрированы в архитектуру конкретных фреймворков и зависели от их внутренних соглашений, стилей кодирования и точек расширения. Попытки переноса подобных решений между проектами зачастую приводили к конфликтам, обусловленным различиями в API, структуре кода и механизмах интеграции.

Symfony \cite{symfony2005release} стал одним из первых фреймворков, предпринявших системную попытку преодолеть эту фрагментацию за счёт внедрения компонентного подхода \cite{fabpot2012symfonycomponents} (начиная с Symfony 2 \cite{symfony2011release}), однако в отсутствие общепринятых отраслевых стандартов такой подход оставался локальным решением, которое не обеспечивало гарантированной совместимости и стабильности интеграций.

\subsection{Отсутствие стандартизированной модели HTTP}

Одним из ключевых технологических ограничений PHP-экосистемы до появления общих стандартов являлось отсутствие унифицированного представления основных HTTP-компонентов: запроса, ответа, а также их атрибутов, заголовков и потоков данных.

Каждый из ведущих фреймворков реализовывал собственные, несовместимые между собой классы для работы с HTTP-слоем:

\begin{itemize}
    \item HttpFoundation \cite{symfonyhttpfoundation} в Symfony;
    \item Http \cite{zendhttp} (Request / Response) в Zend;
    \item Http \cite{slimhttp} в Slim;
    \item Собственные реализации в CakePHP \cite{cakephphttp}.
\end{itemize}

Такая фрагментация затрудняла разработку взаимозаменяемых middleware-компонентов, снижала переносимость кода между проектами и препятствовала созданию единых решений для HTTP-клиентов, фильтров и других инструментов обработки запросов.

Глубина проблемы подтверждается продолжительностью обсуждения стандарта PSR-7 \cite{psr7standard} в рабочих группах PHP-FIG: дискуссии по его формулировке велись почти три года. Это свидетельствует о фундаментальном характере задачи стандартизации HTTP-интерфейсов для всей экосистемы.

\subsection{Отсутствие единых правил для автозагрузки и управления зависимостями}

До появления Composer \cite{seldaek2012composer} и принятия стандарта PSR-4 \cite{psr4standard} (2013–2014 гг.) подключение сторонних библиотек в PHP-проектах, как правило, осуществлялось вручную с использованием конструкций \texttt{require/include}. Декларативное управление зависимостями фактически отсутствовало, а распространение кода происходило преимущественно через архивы в формате ZIP или посредством системы PEAR.

Отсутствие унифицированных правил автозагрузки классов обусловливало жёсткую привязку к структуре каталогов и способствовало частым конфликтам версий библиотек.

Ситуация принципиально изменилась с появлением Composer \cite{seldaek2012composer}, который ввёл централизованный и декларативный механизм управления зависимостями и автозагрузкой. Однако его широкое внедрение в промышленную разработку началось лишь в 2014–2015 гг. Этот период стал отправной точкой для изменений, анализируемых в последующих разделах.

\subsection{Проблемы тестируемости и внедрения зависимостей}
До принятия стандарта PSR-11 \cite{psr11standard} (Container Interface) каждый из ведущих PHP-фреймворков реализовывал собственный контейнер внедрения зависимостей (DI-контейнер), причём эти реализации не были совместимы между собой. К числу наиболее распространённых решений относились:


\begin{itemize}
    \item Symfony Dependency Injection \cite{symfonydependencyinjection};
    \item Laravel Container \cite{laravelcontainer};
    \item Zend Service Manager \cite{zendservicemanager};
    \item Pimple \cite{pimple}.
\end{itemize}

Отсутствие унифицированного интерфейса контейнера создавало ряд системных ограничений:

\begin{itemize}
    \item затрудняло разработку многократно используемых пакетов, не привязанных к конкретному фреймворку;
    \item делало невозможным перенос middleware-компонентов и других сервисов между проектами;
    \item замедляло развитие архитектур, основанных на принципах внедрения зависимостей и их управления.
\end{itemize}

Таким образом, архитектура внедрения зависимостей представляла собой одну из ключевых проблем экосистемы PHP, решение которой стало возможным лишь в последние 10 лет (2015–2025) в ходе стандартизации — в частности, с принятием PSR-11 \cite{psr11standard}.

\section{Развитие стандартов и архитектурных решений в экосистеме PHP (2015–2025)}

Период 2015–2025 годов стал для PHP-фреймворков этапом глубокой технологической трансформации.

В предшествующее десятилетие (2005–2015) были сформулированы и заложены фундаментальные концепции, определившие дальнейшее развитие экосистемы: создание PHP-FIG \cite{phpfig2009charter}, появление менеджера зависимостей Composer \cite{seldaek2012composer}, а также разработка PSR, первых стандартов PHP \cite{psr0standard}, включая PSR-4 \cite{psr4standard}, PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard}.

Однако качественный переход к современной архитектуре веб-приложений начался лишь после выхода PHP 7 \cite{php7rfc2015} и  широкого внедрения ключевых стандартов — PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard} и PSR-15 \cite{psr15standard}.

В данном разделе рассматриваются ключевые архитектурные изменения, произошедшие в указанный период, анализируются предпосылки их возникновения и оценивается их влияние на эволюцию PHP-экосистемы.

\subsection{Composer как фундамент модернизации экосистемы}

Менеджер зависимостей Composer \cite{seldaek2012composer} был впервые выпущен в 2012 году, однако его широкое внедрение в PHP-экосистеме произошло в 2015–2017 гг. Именно в этот период подавляющее большинство фреймворков и сторонних библиотек перешли на декларативную модель управления зависимостями.

Как отмечалось выше, до внедрения Composer управление зависимостями оставалось фрагментированным и неформализованным, что создавало ряд проблем при сопровождении крупных проектов и осложняло архитектурную эволюцию фреймворков.

Composer предложил унифицированное решение, включавшее декларативное описание зависимостей с помощью \texttt{composer.json} \cite{composerJsonSchema}, стандартизированный механизм автозагрузки классов на основе PSR-4 \cite{psr4standard}, поддержку семантического версионирования (SemVer) \cite{semver} и централизованный репозиторий пакетов Packagist \cite{packagist}.

Благодаря этим инновациям архитектурная парадигма PHP-фреймворков трансформировалась: они перестали восприниматься как монолитные системы и стали рассматриваться как композиции слабосвязанных, автономных компонентов, пригодных к обособленному выбору, комбинированию и обновлению.

К началу 2020-х годов Composer фактически закрепился в качестве инфраструктурного стандарта PHP-экосистемы. Это привело к снижению привязки библиотек к конкретным фреймворкам, ускорению обмена компонентами между проектами и формированию устойчивой культуры разработки фреймворк-независимых пакетов, ориентированных на повторное использование.

% \subsubsection{Причины изменения:}
% До Composer \cite{seldaek2012composer} управление зависимостями основывалось на:
% \begin{itemize}
%     \item Ручном подключении файлов через \texttt{require} или \texttt{include}.
%     \item Распространении пакетов через \texttt{ZIP}-архивы или \texttt{PEAR}.
%     \item Отсутствии разрешения конфликтов версий.
% \end{itemize}

% Это приводило к «зависимостному аду» \cite{dependencyHellWikipedia} и мешало развитию фреймворков.

% \subsubsection{Принятое решение}

% Composer \cite{seldaek2012composer} ввёл:

% \begin{itemize}
%     \item файл \texttt{composer.json} \cite{composerJsonSchema} в качестве декларации зависимостей.
%     \item Автозагрузчик, основанный на PSR-4 \cite{psr4standard}.
%     \item Семантическое версионирование \cite{semver}.
%     \item Центральный репозиторий \texttt{Packagist} \cite{packagist}.
% \end{itemize}

% Философия Composer \cite{seldaek2012composer} повлияла на всю экосистему: фреймворки стали не «монолитами», а наборами компонентов, которые можно выбирать, комбинировать и обновлять независимо.


% \subsubsection{Результаты}
% \begin{itemize}
%     \item Исчезла жёсткая привязка библиотек к конкретным фреймворкам.
%     \item Появилось огромное количество независимых пакетов.
%     \item Разработчики получили прозрачное управление зависимостями.
% \end{itemize}
% Composer \cite{seldaek2012composer} стал фактическим стандартом и сделал возможным внедрение последующих PSR.
\subsection{Развитие PSR и их роль в архитектурной трансформации PHP-экосистемы}

Стандарты PSR, разрабатываемые в рамках PHP-FIG \cite{phpfig2009charter}, стали центральным инструментом преодоления архитектурной фрагментации PHP-экосистемы в период 2015–2025 годов. В отличие от ранних инициатив по унификации, ориентированных на внутреннюю архитектуру отдельных фреймворков, PSR-стандарты были направлены на установление минимальных, но строго определённых контрактов, обеспечивающих совместимость между фреймворками без навязывания конкретных реализаций.

Эта стратегия позволила сформировать общий архитектурный «язык», на котором могли взаимодействовать разнородные компоненты, независимо от их происхождения. Каждый из ключевых стандартов решал узкую, но критически важную проблему совместимости, при этом внося вклад в общую картину модульной и переносимой архитектуры.

В следующих подразделах рассматриваются наиболее влиятельные PSR-стандарты, сыгравшие решающую роль в трансформации PHP-экосистемы: их предпосылки, ключевые положения и архитектурные последствия.
\subsubsection{PSR-4 и единая модель автозагрузки (2015)}

Стандарт PSR-4 \cite{psr4standard} стал решающим этапом в переходе от фрагментированных, фреймворк-специфичных соглашений к единой и предсказуемой модели автозагрузки классов в PHP-экосистеме.

Его практическое значение особенно возросло в период 2015–2020 годов, когда основные фреймворки начали систематически приводить структуру каталогов и организацию пространств имён в соответствие с PSR-4 \cite{psr4standard}. Это, в свою очередь, предоставило менеджеру зависимостей Composer устойчивую основу для генерации стандартизированного автозагрузчика, совместимого с любым соответствующим пакетом.

До принятия PSR-4 \cite{psr4standard} каждый крупный фреймворк использовал собственные, несовместимые между собой правила сопоставления имён классов с путями к файлам. Такая фрагментация затрудняла интеграцию сторонних библиотек, увеличивала сложность сопровождения и негативно сказывалась на масштабируемости проектов.

В отличие от прежней ситуации, когда каждая платформа определяла собственные правила, PSR-4 \cite{psr4standard} формализовал два ключевых принципа: во-первых, строгое соответствие между пространствами имён и иерархией каталогов; во-вторых, возможность автоматической загрузки классов без необходимости использования конструкций \texttt{include} или \texttt{require}.

В результате значительно повысилась переносимость библиотек между проектами, а архитектура фреймворков стала более компонентной: сократилась доля проприетарного инфраструктурного кода, а уровень взаимной совместимости в экосистеме в целом существенно возрос.

% PSR-4 \cite{psr4standard} (2014) стал ключевым переходом от хаотичных соглашений к единообразной системе.

% Но именно в период 2015–2020, когда фреймворки начали массово переписывать внутренние структуры под PSR-4 \cite{psr4standard}.

% \subsubsection{Причины}
% До PSR-4 \cite{psr4standard}:
% \begin{itemize}
%     \item Каждый фреймворк имел собственные правила размещения классов.
%     \item Не было единообразных пространств имён.
%     \item Библиотеки не могли интегрироваться между собой.
% \end{itemize}


% \subsubsection{Принятое решение}
% PSR-4 \cite{psr4standard} определил:
% \begin{itemize}
%     \item Строгие правила сопоставления пространств имён с каталогами.
%     \item Автоматическую загрузку классов без ручных \texttt{include} или \texttt{require}.
% \end{itemize}

% \subsubsection{Результаты}
% \begin{itemize}
%     \item Библиотеки стали взаимозаменяемыми.
%     \item Фреймворки уменьшили собственный «клей» и стали ориентироваться на компоненты.
%     \item Composer \cite{seldaek2012composer} получил техническую основу для генерации стандартизированного автозагрузчика.
% \end{itemize}

% PSR-4 \cite{psr4standard} стал первым шагом к «общему грамматическому строю» всей экосистемы.


\subsubsection{PSR-7 и стандартизация HTTP-модели (2015)}

Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из ключевых факторов в эволюции архитектуры PHP-экосистемы.

До его принятия HTTP-запросы и ответы в каждом фреймворке реализовывались с использованием собственных, несовместимых между собой моделей. Это препятствовало переносу middleware-компонентов и делало практически невозможной разработку взаимозаменяемых HTTP-инструментов — таких как клиенты, маршрутизаторы или фильтры — между различными стеками фреймворков. Кроме того, отсутствовали унифицированные интерфейсы для потоков данных, заголовков и других элементов HTTP-сообщений.

PSR-7 \cite{psr7standard} устранил эту фрагментацию, предложив стандартизированную модель HTTP-сообщений и чётко определённый набор интерфейсов для основных сущностей: \texttt{Request}, \texttt{Response}, \texttt{Stream}, \texttt{UploadedFile} и \texttt{URI}.

Практическим следствием стандарта стало развитие middleware-компонентов и переносимых HTTP-библиотек. В экосистеме утвердились нативные PSR-7-совместимые реализации, такие как Slim 3 \cite{slim3} и Zend Diactoros \cite{zenddiactoros}. Крупные фреймворки также адаптировались к новой реальности: Symfony внедрил специализированные PSR-7-бриджи \cite{symfonypsr7bridges}, а Laravel обеспечил совместимость через интеграционные слои \cite{laravelpsr7compatibility}.

Таким образом, PSR-7 \cite{psr7standard} не только решил проблему фрагментации HTTP-интерфейсов, но и заложил архитектурную основу для последующей стандартизации — в частности, для разработки контрактов \texttt{middleware} в PSR-15 \cite{psr15standard}.

% Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из наиболее значимых изменений за всё время развития экосистемы PHP-фреймворков.

% \subsubsection{Причины}

% До PSR-7:

% \begin{itemize}
%     \item Каждый фреймворк представлял HTTP-запрос/ответ по-своему.
%     \item Невозможно было переносить \texttt{middleware}.
%     \item Невозможно было использовать один и тот же HTTP-клиент или роутер между фреймворками.
%     \item Не существовало общего интерфейса потоков \texttt{streams}, \texttt{cookies}, \texttt{headers}.
% \end{itemize}

% \subsubsection{Принятое решение}

% PSR-7 создал единый интерфейс для:

% \begin{itemize}
%     \item \texttt{Request}.
%     \item \texttt{Response}.
%     \item \texttt{Stream}.
%     \item \texttt{UploadedFile}.
%     \item \texttt{URI}.
% \end{itemize}

% Это впервые позволило библиотекам работать независимо от фреймворка.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item Появление Slim 3 \cite{slim3}, Zend Diactoros \cite{zenddiactoros}, Guzzle PSR-7 clients \cite{guzzlepsr7clients}.
%     \item Появление кросс-фреймворковых \texttt{middleware}.
%     \item Symfony добавил PSR-7-бриджи \cite{symfonypsr7bridges}.
%     \item Laravel адаптировал совместимость на уровне интеграций \cite{laravelpsr7compatibility}.
% \end{itemize}

% PSR-7 \cite{psr7standard} стал фундаментом для PSR-15 \cite{psr15standard} и новой культуры \texttt{middleware} в PHP.
\subsubsection{PSR-11 и унификация DI-контейнеров (2017)}
Ещё одной существенной проблемой PHP-экосистемы до стандартизации являлась несовместимость контейнеров внедрения зависимостей: такие фреймворки, как Laravel \cite{laraveldocs}, Symfony \cite{symfonydependencyinjection} и Zend Framework, реализовывали собственные, взаимно несовместимые API, что не позволяло сторонним библиотекам запрашивать зависимости абстрактно и переносимо.

Принятие стандарта PSR-11 \cite{psr11standard} устранило данный барьер, определив спецификацию контейнера в виде двух интерфейсов: \texttt{ContainerInterface} и \texttt{NotFoundExceptionInterface}.

Благодаря этому сторонние компоненты получили возможность взаимодействовать с DI-контейнером без привязки к конкретному фреймворку. В результате внедрение зависимостей трансформировалось из внутреннего механизма отдельных фреймворков в общую экосистемную практику. Это способствовало снижению фрагментации пакетов и упростило разработку переносимых компонентов, совместимость которых обеспечивается исключительно соответствием требованиям PSR-11 \cite{psr11standard}.

% Ещё одной ключевой проблемой PHP-фреймворков была несовместимость контейнеров зависимостей.

% \subsubsection{Причины}

% До PSR-11:
% \begin{itemize}
%     \item Каждый фреймворк имел собственный DI.
%     \item Пакеты не могли объявлять зависимости абстрактно.
%     \item Невозможно было использовать библиотеку, требующую объект из контейнера другого фреймворка.
% \end{itemize}

% Контейнеры Laravel, Symfony, Zend имели разные API.

% \subsubsection{Принятое решение}

% PSR-11 ввёл два интерфейса:

% \begin{itemize}
%     \item \graybox{ContainerInterface}.
%     \item \graybox{NotFoundExceptionInterface}.
% \end{itemize}

% Разработчики библиотек получили способ запрашивать зависимости без привязки к конкретному фреймворку.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item DI стал общим архитектурным механизмом, а не «особенностью» конкретного фреймворка.
%     \item \graybox{Middleware}-компоненты стали переносимыми.
%     \item Снизилась фрагментация библиотек.
% \end{itemize}

% PSR-11 \cite{psr11standard} способствовал развитию переносимых компонентов и библиотек, которым требуется доступ к контейнеру зависимостей без привязки к конкретному фреймворку.

\subsubsection{PSR-15 и middleware-архитектура (2017–2018)}
После принятия стандарта PSR-7 \cite{psr7standard}, унифицировавшего представление HTTP-сообщений, стала возможной дальнейшая стандартизация самой модели обработки запросов через цепочки middleware.

До появления PSR-15 \cite{psr15standard} фреймворки применяли несовместимые подходы к организации middleware-слоя: так, Symfony использовал компонент HttpKernel, Laravel — собственные фильтры и middleware-механизмы, тогда как последовательная middleware-архитектура, основанная на цепочках обработчиков, была характерна лишь для отдельных стеков, таких как Slim \cite{slim4} и Zend Expressive (впоследствии Mezzio) \cite{zendexpressive}.

Стандарт PSR-15 \cite{psr15standard} формализовал два базовых интерфейса: \texttt{MiddlewareInterface} и \texttt{RequestHandlerInterface}.

Это приблизило PHP-экосистему к устоявшимся в других языках моделям обработки запросов через middleware-цепочки — таким как Rack (Ruby), WSGI (Python) и Connect/Express (Node.js).

Практическое значение PSR-15 \cite{psr15standard} заключалось в ускорении разработки переносимых middleware-компонентов и обеспечении единой основы для middleware-ориентированных фреймворков, включая Mezzio \cite{zendexpressive} и Slim 4 \cite{slim4}. Фреймворки с иной архитектурой, такие как Symfony и Laravel, сохранили свои внутренние модели, но обеспечили совместимость с PSR-15 посредством адаптеров и мостов \cite{symfonypsr7bridges, laravelpsr7compatibility}.

В результате \texttt{middleware} превратился в одну из ключевых архитектурных единиц проектирования современных PHP-приложений.





\subsection{Влияние PHP 7 и PHP 8 на архитектуру фреймворков}

Эволюция языка PHP в версиях 7 \cite{php7rfc2015} (2015) и 8 \cite{php8typingrfc2020} (2020) оказала фундаментальное воздействие на архитектурные основы современных PHP-фреймворков, инициировав переход от динамической, слабо типизированной модели к более строгой и предсказуемой парадигме проектирования. Ключевым сдвигом стало не просто ускорение выполнения кода или расширение возможностей, а изменение самой культуры взаимодействия компонентов: язык стал требовать от разработчиков — и, соответственно, от фреймворков — большей формальной точности, что напрямую отразилось на проектировании API, управлении зависимостями и организации внутренней логики приложений.

С выходом PHP 7 \cite{php7rfc2015} архитектура PHP-разработки начала кардинально меняться. Переход от нефатальных ошибок и предупреждений к строгой модели на основе исключений, а также появление скалярной типизации и возвращаемых типов позволили оформлять контракты между компонентами на уровне самого кода, а не в виде комментариев. Это побудило фреймворки отказываться от неявных соглашений и динамических зависимостей, которые ранее служили источником ошибок и снижали сопровождаемость. Интерфейсы стали проектироваться как строго типизированные контракты, в которых сигнатуры методов выражали не просто реализацию, а архитектурную спецификацию.

Особенно заметным стало влияние этих изменений на контейнеры внедрения зависимостей. Возможность управлять зависимости на основе типов, поддерживаемых автоматическим связыванием и строгими сигнатурами, позволила сократить объём конфигурационного кода и повысить прозрачность архитектуры.

Релиз PHP 8 \cite{php8typingrfc2020} усилил и закрепил эти тенденции, добавив важные механизмы, которые ещё больше повысили декларативность и явность архитектуры. Введение объединений (Union Types) устранило необходимость в избыточной проверке типов внутри методов и позволило точно описывать допустимые варианты входных и выходных данных. Атрибуты позволили перенести метаданные, ранее размещавшиеся в конфигурационных файлах или PHPDoc-аннотациях, непосредственно в тело кода, сделав маршрутизацию, сериализацию, валидацию и другие аспекты логики явными и локализованными. А выражение match, являясь типобезопасной и компактной альтернативой switch, также способствовало написанию более корректного и лаконичного кода.

В результате таких изменений в экосистеме фреймворков усилилось применение строгих архитектурных паттернов: получили широкое распространение Объекты передачи данных (DTO), Объекты-Значения (Value Objects) и неизменяемые структуры данных. Эти подходы, ранее считавшиеся излишне формальными для PHP-среды, стали практически применимыми благодаря возможностям типизации и предсказуемости поведения кода.

Крупнейшие фреймворки, такие как Symfony и Laravel \cite{laraveldocs}, адаптировались к этим изменениям, сохраняя свои особенности, но двигаясь в едином направлении. Symfony сосредоточился на максимальной интеграции с возможностями языка, усилив типобезопасность компонентов и оптимизировав контейнер зависимостей \cite{symfonydependencyinjection}, тогда как Laravel \cite{laraveldocs}, оставаясь ориентированным на удобство, постепенно сокращал использование неявной «магии» и усиливал контрактность своих API. В обоих случаях развитие самого языка стало не внешним обстоятельством, а внутренним драйвером архитектурной трансформации.

Таким образом, влияние PHP 7 \cite{php7rfc2015} и PHP 8 \cite{php8typingrfc2020} на фреймворки проявилось не в виде изолированных языковых нововведений, а как формирование новой дисциплины проектирования, ориентированной на явные контракты, модульность и формальную корректность. Эти изменения не только повысили надёжность и сопровождаемость PHP-приложений, но и сблизили экосистему с архитектурными практиками, принятыми в других современных серверных платформах, тем самым закрепив переход PHP от «скриптового» языка к стабильной среде для построения сложных, масштабируемых систем.


\subsection{Влияние Symfony на развитие компонентной модели в PHP}

Symfony оказал определяющее влияние на архитектурную трансформацию PHP-экосистемы, выступив не только в роли полноценного веб-фреймворка, но и в качестве поставщика универсальных инфраструктурных компонентов.

Этот переход от монолитной модели «полного фреймворка» к совокупности автономных, слабосвязанных компонентов \cite{fabpot2012symfonycomponents} — таких как HttpFoundation \cite{symfonyhttpfoundation}, EventDispatcher, Console \cite{symfonyconsole} и Routing \cite{symfonyrouting} — стал ответом на ключевые проблемы PHP-экосистемы. Компоненты разрабатывались как независимые библиотеки с чётко определёнными интерфейсами и минимальными внешними зависимостями, что обеспечило их применимость вне контекста самого Symfony. Подобный подход соответствовал инициативам PHP-FIG \cite{phpfig2009charterphpfig}, способствуя активной интеграции Symfony с отраслевыми стандартами, в частности с PSR-7 и PSR-11 \cite{symfonypsr7bridges, psr11standard}, и тем самым укрепляя совместимость на уровне фундаментальных абстракций.

Дальнейшее развитие архитектуры фреймворка сопровождалось внедрением механизмов автосвязывания (autowiring) \cite{symfonyautowiring} и автоконфигурации (auto-configuration), ставших возможными благодаря усилению типобезопасности и развитию рефлексии в PHP 7 и PHP 8. Эти механизмы позволили значительно сократить объём явной конфигурации, перенося информацию о структуре зависимостей непосредственно в сигнатуры классов. В результате архитектура приложений приблизилась к декларативной модели, в которой связи между компонентами становятся явными, предсказуемыми и верифицируемыми на этапе статического анализа, что снижает нагрузку при разработке и сопровождении масштабных систем.

Кульминацией компонентной культуры Symfony стало появление Symfony Flex — инфраструктурного решения, переосмыслившего процесс сборки приложения как динамическую композицию пакетов и конфигураций. Эта модель устранила необходимость в фиксированной структуре фреймворка и позволила разработчикам гибко конструировать приложения под конкретные задачи, используя только необходимые компоненты.

Таким образом, Symfony сформировал ядро инфраструктурной конвергенции в PHP-экосистеме, вне зависимости от языкового ядра, а его компонентная модель легла в основу современных подходов к разработке расширяемых, переносимых и стандартизированных систем.

\subsection{Laravel как проводник DX-практик в PHP-экосистеме}

Laravel \cite{laravelpopularity} в период 2015–2025 годов утвердился как ведущий фреймворк, ориентированный на максимальное удобство разработки и единообразие интерфейсов. В отличие от Symfony, Laravel \cite{laraveldocs} изначально был нацелен на снижение порога входа и унификацию практик прикладной разработки, что обусловило его широкую популярность среди как начинающих, так и опытных разработчиков.

Архитектурная траектория Laravel в указанный период характеризуется постепенной интеграцией стандартов PHP-FIG при одновременном сохранении высокоуровневых, локальных абстракций. Ключевым этапом стало принятие Composer \cite{seldaek2012composer} в качестве менеджера зависимостей и внедрение PSR-4 \cite{psr4standard} для автозагрузки классов, что позволило интегрировать Laravel \cite{laraveldocs} в общую экосистему PHP-пакетов и отказаться от проприетарных механизмов загрузки. Поддержка PSR-11 \cite{psr11standard} была реализована частично: собственный контейнер сохранил уникальный API, однако получил совместимость на уровне интерфейсов, обеспечив возможность подключения сторонних библиотек без радикальной перестройки внутренней архитектуры.

Значительным шагом в направлении конвергенции с общеотраслевыми архитектурными практиками стало внедрение middleware-модели, совместимой с PSR-15 \cite{psr15standard}. Несмотря на сохранение собственного контракта для middleware, Laravel \cite{laraveldocs} предоставил механизмы адаптации PSR-совместимых компонентов, что позволило использовать унифицированные подходы к обработке HTTP-запросов без нарушения обратной совместимости.

Эволюция самого языка PHP, в особенности в версиях 7 \cite{php7rfc2015} и 8 \cite{php8typingrfc2020}, оказала прямое влияние на внутреннюю структуру фреймворка. При этом Laravel \cite{laraveldocs} интегрировал новые языковые возможности таким образом, чтобы они не снижали читаемость и выразительность кода, сохранив баланс между архитектурной дисциплиной и удобством использования.

Особую роль в расширении функциональных границ фреймворка сыграло появление специализированных инфраструктурных инструментов — Horizon, Octane, Sail и Pint. Эти компоненты вывели Laravel за пределы традиционного HTTP-слоя, превратив его в полноценную платформу, охватывающую весь жизненный цикл приложения — от локальной разработки и тестирования до эксплуатации в высоконагруженных средах.

В совокупности эти изменения закрепили за Laravel роль центрального элемента стандартизированной PHP-экосистемы. Таким образом, Laravel выступил не только как пассивный реципиент архитектурных трансформаций, но и как активный проводник их в прикладную разработку, оказывая существенное влияние на индустриальные практики и образовательные траектории в PHP-сообществе.

\section{Отклоненные и отложенные инициативы}

Как и в случае с другими устоявшимися программными экосистемами, процесс стандартизации PHP-фреймворков сопровождался не только успешными инициативами, но и значительным числом предложений, которые не были приняты или были сознательно отложены. Анализ этих инициатив представляет особый интерес, поскольку позволяет выявить границы применимости стандартизации и понять, какие архитектурные решения были признаны избыточными, рискованными либо концептуально несоответствующими направлению развития экосистемы.

В данном разделе рассматриваются наиболее показательные инициативы, не приведшие к формированию стандарта. Их анализ позволяет дополнить картину развития PHP-экосистемы и продемонстрировать, что зрелость технологии проявляется не только в способности к унификации, но и в умении своевременно отказаться от чрезмерной стандартизации.

\subsection{Нереализованный стандарт маршрутизации (Router PSR)}

Одной из наиболее обсуждаемых, но так и не реализованных инициатив в рамках PHP-FIG \cite{phpfig2009charter} стало предложение по стандартизации интерфейса маршрутизации HTTP-запросов — Router PSR \cite{figrouterdiscussion}. С 2015 года эта тема неоднократно выносилась на обсуждение в рассылках FIG, что свидетельствует как о её практической актуальности, так и о принципиальных трудностях формализации данного архитектурного уровня.

Потребность в стандарте обусловливалась значительной фрагментацией подходов к маршрутизации в экосистеме PHP. Например, Laravel применял декларативную синтаксическую модель (fluent API) \cite{laravelrouting}, тогда как Symfony использовал аннотации, YAML и PHP-конфигурации \cite{symfonyrouting}. В то же время Slim и Mezzio применяли подход, в котором маршрутизация реализовывалась посредством \textit{middleware} \cite{slimrouting}. Отдельную нишу занимали минималистичные библиотеки вроде FastRoute \cite{fastroute}, реализующие чисто функциональный подход без какой-либо фреймворк-специфической логики. Отсутствие общего интерфейса исключало возможность создания переносимых компонентов — будь то универсальные middleware, инструменты для тестирования маршрутов или декларативные DSL.

Однако в ходе обсуждений в 2016–2018 годах стало очевидно, что различия между этими моделями носят не поверхностный, а концептуальный характер. Controller-based (Laravel \cite{laravelrouting}, Symfony \cite{symfonyrouting}) и middleware-based (Slim \cite{slimrouting}, Mezzio) подходы предполагают разные точки интеграции и жизненные циклы обработки запроса. Попытки выработать единый интерфейс неизменно сталкивались с дилеммой: либо предложить слишком абстрактный контракт, не обеспечивающий практической пользы, либо зафиксировать архитектурные предпочтения одной из моделей, тем самым ограничив свободу проектирования фреймворков.

Ключевым фактором отказа от стандартизации стало также стратегическое стремление PHP-FIG избегать регулирования высокоуровневых архитектурных решений. В условиях активной эволюции подходов к проектированию веб-приложений подобное ограничение было сочтено контрпродуктивным.

В итоге инициатива Router PSR была закрыта как недостаточно универсальная и потенциально ограничивающая. Сообщество пришло к консенсусу: маршрутизация остаётся внутренним делом каждого фреймворка, а взаимодействие между разнородными архитектурами обеспечивается на более низком уровне — через уже устоявшиеся стандарты PSR-7 \cite{psr7standard} и PSR-15 \cite{psr15standard}.

\subsection{Попытка стандартизации ORM и абстракции баз данных}

В экосистеме PHP на протяжении нескольких лет обсуждалась возможность создания стандарта для унифицированного доступа к данным, функционально сопоставимого с JDBC в экосистеме Java. В период с 2014 по 2020 год в рабочих группах и рассылках PHP-FIG неоднократно поднимался вопрос о разработке общего интерфейса для объектно-реляционных отображений (ORM) \cite{figormdiscussion}.

На момент начала обсуждений в PHP-сообществе уже существовало несколько зрелых и широко используемых ORM-решений, включая Doctrine ORM \cite{doctrineorm}, Eloquent ORM \cite{eloquentorm}, Propel \cite{propelorm} и RedBeanPHP \cite{redbeanphp}. Однако эти библиотеки реализовывали принципиально разные архитектурные парадигмы. Doctrine ORM развивалась в русле концепций Domain-Driven Design и паттерна Unit of Work, предполагая строгую типизацию доменных моделей и явное управление жизненным циклом объектов. Eloquent ORM, напротив, следовал классическому паттерну Active Record, интегрируя логику доступа к данным непосредственно в сущности и активно используя динамические методы. Propel делала ставку на генерацию кода на основе декларативных XML-схем, обеспечивая строгую синхронизацию модели с базой данных, тогда как RedBeanPHP предлагала полностью динамический подход, допускающий эволюцию схемы данных в процессе выполнения приложения.

Эти различия оказались не синтаксическими, а концептуальными: каждая модель предполагала особый способ проектирования домена, управления состоянием и взаимодействия с реляционным хранилищем. Дополнительным аргументом против стандартизации стало стремление избежать повторения опыта Java EE, где преждевременная канонизация persistence-слоя привела к усложнению экосистемы.

В итоге инициатива по созданию PSR для ORM была признана нежизнеспособной. Отказ от стандартизации в этой области следует рассматривать не как неудачу, а как осознанный архитектурный выбор: сообщество предпочло сохранить разнообразие культур работы с данными, предоставив разработчикам свободу выбора инструмента, наиболее соответствующего задачам проекта и принятой архитектурной дисциплине.




\subsection{Ограниченная применимость стандарта PSR-14 (Event Dispatcher)}

Стандарт PSR-14 \cite{psr14standard}, посвящённый диспетчеризации событий, был официально утверждён PHP-FIG в 2019 году, однако его разработка сопровождалась продолжительными и во многом противоречивыми дискуссиями в рассылках сообщества \cite{figpsr14discussion}.

Ключевая сложность стандартизации заключалась в фундаментальных различиях архитектурных моделей, применяемых в ведущих PHP-фреймворках. Symfony использует синхронную модель диспетчеризации \cite{symfonyevents}, в которой события представляют собой объекты, а обработчики (слушатели) вызываются последовательно. Laravel, напротив, разделяет понятия события и слушателя более декларативно, активно интегрируя механизмы асинхронной обработки через очереди и поддержку broadcast-событий \cite{laravalevents}. В Zend Framework применяется модель агрегаторов событий \cite{zendEventManager}, допускающая сложную композицию обработчиков и гибкое управление их приоритетами.

Эти различия затрагивают не только сигнатуры API, но и семантические аспекты обработки: порядок выполнения слушателей, возможность прерывания цепочки, управление состоянием события, а также взаимодействие с асинхронной инфраструктурой. Учёт всех этих факторов в едином стандарте оказался невозможным без наложения архитектурных ограничений. В результате PSR-14 \cite{psr14standard} был сформулирован как крайне минималистичный контракт, определяющий лишь метод \texttt{dispatch(\$event)}, без каких-либо предписаний относительно жизненного цикла события, порядка обработки или механизма подписки.

Несмотря на формальное принятие, практическое внедрение PSR-14 \cite{psr14standard} в экосистему остаётся ограниченным. Большинство фреймворков продолжают использовать собственные, более выразительные системы событий, а совместимость с PSR-14, где она реализована, зачастую носит формальный или адаптерный характер. Таким образом, PSR-14 служит наглядной иллюстрацией границ применимости стандартизации: в областях, где архитектурные различия носят не технический, а концептуальный характер, даже формальный консенсус не обеспечивает реальной совместимости.

\subsection{Попытка стандартизации валидации и форм}

Идея стандартизации механизмов валидации данных и обработки форм обсуждалась в PHP-сообществе эпизодически в период с 2016 по 2021 годы \cite{figvalidationdiscussion}. Поводом для дискуссий стало сосуществование нескольких зрелых, но архитектурно несовместимых решений, активно применяемых в ведущих фреймворках и библиотеках.

Так, Symfony реализует формально строгую и высоко расширяемую модель \cite{symfonyform, symfonyvalidator}, основанную на объектном представлении форм и валидационных ограничений, где правила встроены в аннотации или конфигурационные объекты. Laravel, напротив, использует декларативный подход \cite{laravelvalidation}, в котором валидация задаётся правилами и тесно интегрирована с HTTP-запросами и процессом обработки входных данных. Отдельную нишу занимает библиотека Respect/Validation \cite{respectvalidation}, предлагающая функциональный стиль с возможностью композиции правил через текучие интерфейсы (fluent interface).

Эти различия выходят далеко за рамки синтаксиса API. Они затрагивают уровень абстракции, природу используемых DSL, стратегии интеграции с бизнес-логикой и даже философские взгляды на роль валидации в приложении. Попытка выработать единый стандарт неизбежно привела бы либо к чрезмерному упрощению, лишающему решения выразительности, либо к канонизации одной из парадигм в ущерб другим. Более того, сообщество PHP традиционно рассматривает валидацию как область, тесно связанную с эволюцией моделей данных, пользовательских интерфейсов и практик проектирования, и потому требующую пространства для экспериментов.

В результате инициатива по созданию отдельного PSR для валидации и форм была отклонена. Этот отказ от стандартизации подчёркивает важное методологическое различие: в то время как инфраструктурные уровни (например, HTTP-сообщения или контейнеры зависимостей) выигрывают от унификации, высокоуровневые механизмы, напрямую связанные с бизнес-логикой и пользовательским опытом, требуют архитектурной гибкости и разнообразия подходов.


\subsection{PSR-18 и границы стандартизации HTTP-клиентов}

Стандарт PSR-18 \cite{psr18standard}, посвящённый унификации HTTP-клиентов, был утверждён PHP-FIG в 2019 году, однако, как и предыдущие инициативы, его разработка сопровождалась продолжительными дискуссиями в рассылках сообщества \cite{figpsr18discussion}.

Одной из ключевых точек напряжения стала модель обработки ошибок. Часть участников настаивала на использовании исключений как основного механизма сигнализации о сбоях, в то время как другие выступали за подход, при котором клиент всегда возвращает объект ответа, а ошибки обрабатываются как часть бизнес-логики.

Дополнительную сложность вносило разнообразие архитектурных подходов в существующих библиотеках. Guzzle \cite{guzzlehttp}, будучи наиболее распространённым решением, исторически развивался как синхронный клиент с опциональной поддержкой асинхронности через промисы. HTTPlug \cite{httplug} позиционировался как абстрактный адаптерный слой, позволяющий переключаться между различными реализациями без привязки к конкретному клиенту. Symfony HttpClient \cite{symfonyhttpclient}, в свою очередь, проектировался как глубоко интегрированный компонент экосистемы Symfony с акцентом на расширяемость, поддержку потоковой передачи и тонкий контроль над транспортным уровнем. Попытки выработать единый интерфейс, способный органично включать все эти модели, неизбежно приводили к коллизии требований.

В ходе обсуждений активно рассматривались предложения по включению асинхронных интерфейсов в стиле Promise, унифицированного API для стриминга и механизмов отмены запросов. Однако расширение стандарта на эти функциональные области значительно повысило бы его сложность и, как следствие, снизило бы вероятность его принятия и практического внедрения ключевыми реализациями.

В итоге PHP-FIG принял решение ограничиться минималистичным синхронным интерфейсом, определяющим лишь базовый метод sendRequest (RequestInterface). Несмотря на критику со стороны части сообщества, такой подход позволил зафиксировать минимально необходимый общий знаменатель и обеспечить базовую совместимость между различными HTTP-клиентами.

Таким образом, PSR-18 \cite{psr18standard} стал примером осознанного архитектурного компромисса: стандартизация была проведена строго на уровне, достаточном для совместимости, но без попытки унифицировать сложные, концептуально разнородные аспекты клиентского сетевого взаимодействия. Это решение подчёркивает эволюцию стратегии PHP-FIG — от амбициозных унификаций к прагматичным, минимально достаточным контрактам.

\subsection{Инициатива унификации конфигурации DI-контейнеров (расширение PSR-11)}

После утверждения PSR-11 \cite{figpsr11expansion}, определившего минимальный интерфейс контейнера внедрения зависимостей, в сообществе PHP-FIG неоднократно поднимался вопрос о его расширении. В частности, обсуждалась возможность стандартизации механизмов регистрации сервисов, описания фабрик и задания конфигурационных параметров — шаг, который, в теории, мог бы обеспечить полную взаимозаменяемость DI-контейнеров.

Основной мотивацией инициативы выступало стремление повысить переносимость конфигурации и снизить привязку библиотек к конкретным фреймворкам. Однако уже на ранних этапах обсуждения выявили фундаментальные расхождения в подходах к конфигурированию DI-контейнеров, характерных для ведущих PHP-фреймворков.

Так, Symfony \cite{symfonydependencyinjection} использует декларативную модель, в которой конфигурация задаётся через YAML, XML или PHP-файлы и транслируется в строго типизированный контейнер с предсказуемым поведением. Laravel, напротив, опирается на динамическую регистрацию сервисов через замыкания (closures) и связывание (bindings) \cite{laravelcontainer}, делая ставку на выразительность, гибкость и минимизацию объёма конфигурационного кода. Laminas реализует подход \cite{laminasdi}, основанный на ассоциативных массивах, подчёркивая явность структуры и простоту композиции конфигураций.

Попытка унифицировать такие модели в рамках единого стандарта неизбежно привела бы либо к переусложнённому и трудно реализуемому интерфейсу, либо к канонизации одного из подходов — с соответствующим ограничением архитектурной автономии остальных решений.

Помимо этого, стандартизация механизмов конфигурирования DI-контейнеров могла бы подавить инновационное развитие в области управления зависимостями и затруднить внедрение новых паттернов.

В итоге было принято сознательное решение сохранить PSR-11 в его минималистичной форме. Этот выбор отражает общую стратегию PHP-FIG: стандартизировать лишь те уровни абстракции, где достигается максимальная совместимость при минимальном вмешательстве в архитектурную философию конкретных фреймворков.

\section{Заключение}

В период с 2015 по 2025 год экосистема PHP-фреймворков претерпела глубокую архитектурную трансформацию, в результате которой веб-разработка на PHP перешла от фрагментированного ландшафта несовместимых решений к единому технологическому пространству, основанному на стандартах, переносимых компонентах и общей инфраструктуре.

Этот переход стал возможным благодаря синергии трёх ключевых факторов: деятельности PHP-FIG, широкому внедрению системы управления зависимостями Composer и эволюции самого языка в версиях PHP 7 и 8. Стандарты PSR-4 \cite{psr4standard}, PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard} и PSR-15 \cite{psr15standard} сформировали ядро новой архитектурной базы. В совокупности они обеспечили унификацию структуры проектов, создали общий слой функциональной совместимости для обработки HTTP-запросов и позволили компонентам, библиотекам и сервисам свободно перемещаться между фреймворками. Composer, в свою очередь, стал технической основой этой экосистемы, устранив искусственные барьеры между проектами и сделав повторное использование кода нормой, а не исключением.

В то же время развитие самого языка — введение строгой типизации, переход к исключительной модели обработки ошибок, появление нативных атрибутов, а также повышение производительности в PHP 7 и PHP 8 — оказало системное влияние на архитектурные практики. Фреймворки были вынуждены пересмотреть внутренние механизмы, сократить использование динамической «магии» и усилить контрактность публичных API. Это, в свою очередь, повысило предсказуемость, тестируемость и сопровождаемость кода.

В этом контексте Symfony утвердился как компонентная платформа, задающая технические ориентиры для всей экосистемы: его независимые компоненты стали стандартом для построения инфраструктурных слоёв. Laravel, сохраняя фокус на удобстве разработки и высокоуровневой выразительности, активно адаптировал PSR-стандарты и современные возможности PHP, одновременно расширяя своё влияние за пределы HTTP-слоя за счет определенного набора инструментов. Оба фреймворка, несмотря на различия в философии, продемонстрировали высокую степень согласованности с современными архитектурными нормами.

Не менее показательными оказались и нереализованные инициативы. Отказ от стандартизации маршрутизации, отсутствие общего интерфейса для ORM, ограниченное применение PSR-14 \cite{psr14standard} и сознательное сохранение PSR-11 в минималистичной форме свидетельствуют о зрелости сообщества: оно осознанно избегает навязывания унификации в тех областях, где архитектурное разнообразие является источником инноваций.

Таким образом, развитие PHP-фреймворков в 2015–2025 годах можно описать как стремление к стандартизации на базовом уровне при сохранении гибкости в проектировании прикладных решений. За это время фреймворки перестали быть замкнутыми системами и стали частями единой экосистемы, где важнее не то, как реализован компонент, а то, как он взаимодействует с другими — через чёткие и общие интерфейсы.

Несмотря на прежние опасения, что PHP устаревает, за последнее десятилетие язык не только сохранил свою популярность, но и значительно обновился. Открытая разработка, обсуждения в группе PHP-FIG и вклад сообществ Symfony и Laravel помогли экосистеме соответствовать современным требованиям: высокой производительности, строгой типизации, модульной структуре и интеграции с инструментами разработки и развёртывания.

В этом смысле 2015–2025 годы стали одним из самых важных этапов в истории PHP — временем, когда зрелая технология не просто выжила, а успешно трансформировалась под новые задачи.
\setmonofont{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{programming_history}

\end{document}
