% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macros see also
% https://tex.stackexchange.com/questions/78101/

% По умолчанию используется шрифт 14 размера.
% Если Вы не влезаете в лимит страниц и нужен 12-й шрифт,
% то уберите опцию [14pt]

\documentclass[14pt, russian]{matmex-diploma-custom}
\usepackage{listings}
\usepackage{xcolor}

\newcommand{\graybox}[1]{%
  \colorbox{lightgray}{\strut #1}%
}


\input{preamble.tex}

\begin{document}

\input{programming_history_title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\pagebreak

\section{Введение}
\thispagestyle{withCompileDate}
PHP играет важную роль в веб-разработке на протяжении почти трёх десятилетий, оставаясь одним из наиболее распространённых серверных языков.

Согласно статистике W3Techs по состоянию на 1 ноября 2025 года, PHP используется в 72.9\% веб-сайтов с определённым языком серверной части \cite{W3Techs}.

Широкая доступность хостинга и относительно низкий порог входа сделали PHP \cite{phplatest} основой для множества систем управления контентом и прикладных веб-решений.

Однако, устойчивость языка и его экосистемы на протяжении длительного периода в значительной степени связана с развитием общих архитектурных практик и стандартов, которые определили индустрию PHP \cite{phplatest}-разработки.

В начале 2000-х годов в ответ на растущую сложность веб-приложений начали формироваться первые полнофункциональные PHP-фреймворки.

CakePHP (2005) \cite{cakephp2005announce}, Symfony (2005) \cite{symfony2005release} и CodeIgniter (2006) \cite{codeigniter2006announce} заложили основы MVC-подхода и упорядочили разработку веб-приложений в условиях отсутствия единых стандартов.

Однако по мере усложнения проектов стало очевидно, что решения того периода сталкиваются с рядом системных ограничений, включая непрозрачную архитектуру, несовместимость компонентов, отсутствие унифицированных интерфейсов и недостаточную тестируемость.

В течение следующего десятилетия (2005–2015) PHP \cite{phplatest}-стек претерпел значительные изменения. Это было связано с разработкой PHP-FIG \cite{phpfig2009charter} и ряда стандартов PSR \cite{psr0standard}, появлением Composer \cite{seldaek2012composer}, унификацией HTTP-модели \cite{psr7standard}, распространением принципов DI \cite{psr11standard} и архитектурой middleware \cite{psr15standard}.

Тем не менее, между 2015 и 2025 годами произошли наиболее значительные структурные изменения в PHP-фреймворках. Эти изменения радикально изменили архитектурные решения, принципы проектирования и практики масштабирования.

Эти преобразования охватывали выход PHP 7 \cite{php7rfc2015}, внедрение массовой типизации и переход к строгой модели обработки ошибок, реорганизацию Symfony \cite{symfony2005release} в рамках компонентной архитектуры, стремительный развитие Laravel \cite{laravel2011announce}, а также упадок Zend \cite{zendframework2006announce} Framework и его последующую трансформацию в проект Laminas.

Цель настоящей работы — провести комплексный анализ ключевых архитектурных и технологических изменений, произошедших в PHP-фреймворках в период с 2015 по 2025 годы. В рамках исследования предполагается выявить причины указанных изменений, оценить эффективность принятых техническиатурных решений, а также определить, какие концепции и подходы были отвергнуты или модифицированы в ходе профессиональных дискуссий.

Для достижения поставленных целей используются следующие источники: материалы рассылок PHP-FIG \cite{phpfig2009charter}, предложения RFC Internals PHP, официальные публикации Symfony \cite{symfony2005release} и Laravel \cite{laravel2011announce}, дискуссии GitHub о стандартах Composer и PSR, а также доклады разработчиков, представленные на профильных конференциях — в частности, SymfonyCon \cite{symfonycon} и Laracon \cite{laracon}.

Таким образом, в статье рассматривается не только эволюция отдельных фреймворков, но и более широкий процесс формирования профессиональной PHP-экосистемы, в которой технологические инновации выступают в качестве ключевого фактора развития.

\section{Особенности развития PHP-экосистемы до стандартизации (до 2015 года)}

К 2015 году промышленная разработка на PHP \cite{phplatest} характеризовалась двойственным положением. С одной стороны, язык сохранял широкое распространение и технологическую зрелость как платформа для веб-приложений, обусловленную простотой развёртывания, высокой доступностью хостинговых решений и устойчивой обратной совместимостью. С другой стороны, PHP-экосистема страдала от существенных архитектурных ограничений, вызванных отсутствием унифицированных стандартов проектирования и низкой совместимостью между ключевыми компонентами. Это приводило к увеличению совокупной стоимости сопровождения проектов, а также замедляло темпы развития как сторонних библиотек, так и фреймворков.
\subsection{Отсутствие единых интерфейсов}
До появления PHP-FIG \cite{phpfig2009charter} в экосистеме PHP отсутствовали общепринятые технические соглашения по ключевым аспектам разработки, включая:

\begin{itemize}
    \item организацию структуры каталогов;
    \item механизмы автоматической загрузки классов;
    \item унифицированное представление HTTP-запросов и ответов;
    \item интерфейсы контейнеров внедрения зависимостей (DI);
    \item стандартные контракты для middleware и модель обработки HTTP-запросов.
\end{itemize}

В результате каждый из ведущих фреймворков, включая Symfony \cite{symfony2005release}, Zend \cite{zendframework2006announce}, CakePHP \cite{cakephp2005announce} и CodeIgniter \cite{codeigniter2006announce}, реализовывал собственные, зачастую несовместимые подходы к решению этих задач. Это привело к эффекту фрагментации экосистемы PHP, при котором фреймворки и библиотеки развивались как изолированные подсистемы с ограниченной совместимостью.

Например, Symfony \cite{symfony2005release} применял собственный автозагрузчик и строгие соглашения об именовании, тогда как Zend предлагал иную структуру каталогов. Многие сторонние библиотеки того времени подключались вручную и не содержали формализованных метаданных о зависимостях, что исключало автоматизированное управление ими.

Такая ситуация приводила к высокой степени связанности между фреймворками и их компонентами. Интеграционные решения часто основывались на неформализованных соглашениях и паттернах, а изменения в деталях реализации нарушали обратную совместимость.

\subsection{Проблема совместимости и отсутствие переиспользуемых компонентов}

Ключевой проблемой периода до 2012–2014 годов была невозможность использовать одну и ту же библиотеку в разных фреймворках.

Например, HTTP-клиенты, логгеры и шаблонизаторы были жестко «привязаны» к конкретному фреймворку, а попытки переносить решения приводили к конфликтам стилей, соглашений и точек расширения.

Symfony \cite{symfony2005release} первым попытался решить эту проблему, выделив «компонентный подход» \cite{fabpot2012symfonycomponents} (начиная с Symfony 2 \cite{symfony2011release}), но без стандартизации на уровне индустрии это был лишь частичный шаг.

Разработчики других фреймворков могли использовать компоненты Symfony, но не было гарантий совместимости.


\subsection{Отсутствие стандартизированной модели HTTP}

Одним из главных технологических ограничений было отсутствие стандартизированного представления:

\begin{itemize}
    \item HTTP-запроса.
    \item HTTP-ответа.
    \item Атрибутов, заголовков, стримов.
\end{itemize}

Каждый фреймворк определял собственные классы:

\begin{itemize}
    \item Symfony HttpFoundation \cite{symfonyhttpfoundation}.
    \item Zend\\Http \cite{zendhttp} (Request / Response).
    \item Slim\\Http \cite{slimhttp}.
    \item Собственные реализации в CakePHP \cite{cakephphttp}.
\end{itemize}

В результате было затруднено создание взаимозаменяемых \texttt{middleware}, переносимость кода между фреймворками и развитие унифицированных HTTP-клиентов и фильтров обработки запросов.

Проблема была настолько глубокой, что в рассылке FIG обсуждение PSR-7 \cite{psr7standard} длилось почти 3 года.
Это ещё один признак того, насколько фундаментальной была задача стандартизации.


\subsection{Отсутствие единых правил автозагрузки и зависимостей}

До релиза Composer \cite{seldaek2012composer} и утверждения PSR-4 \cite{psr4standard} (2013–2014) библиотеки часто подключались вручную через \texttt{require/include}, декларативного управления зависимостями практически не существовало, а поставка кода нередко происходила через ZIP-архивы или PEAR.

Отсутствие единых правил автозагрузки приводило к жёстким требованиям к структуре каталогов и регулярным конфликтам версий.

Composer \cite{seldaek2012composer} радикально изменил эту ситуацию, но его широкое принятие началось только после 2014–2015.

Этот период стал отправной точкой изменений, анализируемых далее.

\subsection{Проблемы тестируемости и внедрения зависимостей}
До принятия PSR-11 \cite{psr11standard} (Container Interface) каждый фреймворк реализовывал собственный DI-контейнер, и ни один из них не был совместим с другим:

\begin{itemize}
    \item Symfony DependencyInjection \cite{symfonydependencyinjection}.
    \item Laravel Container \cite{laravelcontainer}.
    \item Zend\\ServiceManager \cite{zendservicemanager}.
    \item Pimple \cite{pimple}.
\end{itemize}

Отсутствие общего интерфейса:

\begin{itemize}
    \item Усложняло создание многоразовых пакетов.
    \item Делало невозможным перенос middleware-компонентов.
    \item Тормозило развитие архитектур, основанных на инверсии управления.
\end{itemize}

Архитектура DI\footnote{
    \textbf{DI — Dependency Injection}.
    Внедрение зависимостей: объект получает свои зависимости извне, а не создаёт их самостоятельно.
    } была одной из ключевых болевых точек, которую индустрия смогла решить только в последние 10 лет (2015–2025), в ходе стандартизации PSR-11 \cite{psr11standard}.


\section{Развитие стандартов и архитектурных решений в экосистеме PHP (2015–2025)}

Период 2015–2025 годов стал для PHP-фреймворков временем глубокой технологической перестройки.

На протяжении предыдущего десятилетия (2005–2015) были заложены фундаментальные идеи: создание PHP-FIG \cite{phpfig2009charter}, появление Composer \cite{seldaek2012composer}, формирование первых PSR-стандартов \cite{psr0standard}, PSR-4 \cite{psr4standard}, PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard}.

Однако именно после выхода PHP 7 \cite{php7rfc2015} и широкого принятия PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard} начался качественный переход к современной архитектуре веб-приложений.

В этом разделе анализируются ключевые архитектурные изменения, причины их появления и влияние на экосистему.

\subsection{Composer как основа модернизации экосистемы (2015–2025)}
Хотя Composer \cite{seldaek2012composer} был выпущен в 2012 году, его массовое принятие произошло в период 2015–2017 годов: именно тогда большинство фреймворков и библиотек окончательно перешли на декларативное управление зависимостями.

До Composer управление зависимостями оставалось во многом ручным: библиотеки подключались через \texttt{require/include}, распространялись ZIP-архивами или через PEAR, а конфликты версий приходилось разрешать неформальными способами.

Это создавало типичную для крупных проектов проблему несовместимых зависимостей и существенно тормозило развитие фреймворков.

Composer предложил единый механизм описания зависимостей через \gratextttybox{composer.json} \cite{composerJsonSchema}, стандартный автозагрузчик на основе PSR-4 \cite{psr4standard}, практики семантического версионирования \cite{semver} и центральный репозиторий пакетов Packagist \cite{packagist}.

В результате фреймворки стали восприниматься не как монолитные системы, а как композиции из независимых компонентов, которые можно выбирать, комбинировать и обновлять по отдельности.

К 2020-м годам Composer фактически стал инфраструктурным стандартом экосистемы PHP: снизилась привязка библиотек к конкретным фреймворкам, ускорился обмен компонентами между проектами и сформировалась массовая культура разработки пакетов, независимых от выбранного фреймворка.


% \subsubsection{Причины изменения:}
% До Composer \cite{seldaek2012composer} управление зависимостями основывалось на:
% \begin{itemize}
%     \item Ручном подключении файлов через \texttt{require} или \texttt{include}.
%     \item Распространении пакетов через \texttt{ZIP}-архивы или \texttt{PEAR}.
%     \item Отсутствии разрешения конфликтов версий.
% \end{itemize}

% Это приводило к «зависимостному аду» \cite{dependencyHellWikipedia} и мешало развитию фреймворков.

% \subsubsection{Принятое решение}

% Composer \cite{seldaek2012composer} ввёл:

% \begin{itemize}
%     \item файл \texttt{composer.json} \cite{composerJsonSchema} в качестве декларации зависимостей.
%     \item Автозагрузчик, основанный на PSR-4 \cite{psr4standard}.
%     \item Семантическое версионирование \cite{semver}.
%     \item Центральный репозиторий \texttt{Packagist} \cite{packagist}.
% \end{itemize}

% Философия Composer \cite{seldaek2012composer} повлияла на всю экосистему: фреймворки стали не «монолитами», а наборами компонентов, которые можно выбирать, комбинировать и обновлять независимо.


% \subsubsection{Результаты}
% \begin{itemize}
%     \item Исчезла жёсткая привязка библиотек к конкретным фреймворкам.
%     \item Появилось огромное количество независимых пакетов.
%     \item Разработчики получили прозрачное управление зависимостями.
% \end{itemize}
% Composer \cite{seldaek2012composer} стал фактическим стандартом и сделал возможным внедрение последующих PSR.


\subsubsection{PSR-4 и единая модель автозагрузки}
PSR-4 \cite{psr4standard} стал ключевым шагом от разрозненных соглашений к единой, предсказуемой модели автозагрузки.

Практически важным он стал в период 2015–2020 годов, когда фреймворки начали массово приводить внутренние структуры и пространства имён к PSR-4, а Composer получил устойчивую основу для генерации стандартизированного автозагрузчика.

До внедрения PSR-4 каждый крупный фреймворк имел собственные правила размещения классов и сопоставления имён с файлами, что усложняло интеграцию библиотек и повышало стоимость поддержки проектов при росте кодовой базы.

PSR-4 закрепил следующие ключевые требования:

\begin{itemize}
    \item правила сопоставления пространств имён с каталогами;
    \item возможность автозагрузки классов без ручных \texttt{include}/\texttt{require}.
\end{itemize}

В результате библиотеки стали заметно более переносимыми, а сами фреймворки — более «компонентными»: уменьшилась доля собственного инфраструктурного кода и выросла совместимость экосистемы в целом.


% PSR-4 \cite{psr4standard} (2014) стал ключевым переходом от хаотичных соглашений к единообразной системе.

% Но именно в период 2015–2020, когда фреймворки начали массово переписывать внутренние структуры под PSR-4 \cite{psr4standard}.

% \subsubsection{Причины}
% До PSR-4 \cite{psr4standard}:
% \begin{itemize}
%     \item Каждый фреймворк имел собственные правила размещения классов.
%     \item Не было единообразных пространств имён.
%     \item Библиотеки не могли интегрироваться между собой.
% \end{itemize}


% \subsubsection{Принятое решение}
% PSR-4 \cite{psr4standard} определил:
% \begin{itemize}
%     \item Строгие правила сопоставления пространств имён с каталогами.
%     \item Автоматическую загрузку классов без ручных \texttt{include} или \texttt{require}.
% \end{itemize}

% \subsubsection{Результаты}
% \begin{itemize}
%     \item Библиотеки стали взаимозаменяемыми.
%     \item Фреймворки уменьшили собственный «клей» и стали ориентироваться на компоненты.
%     \item Composer \cite{seldaek2012composer} получил техническую основу для генерации стандартизированного автозагрузчика.
% \end{itemize}

% PSR-4 \cite{psr4standard} стал первым шагом к «общему грамматическому строю» всей экосистемы.


\subsection{PSR-7 и стандартизация HTTP-модели (2015)}

Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из наиболее значимых изменений за всё время развития экосистемы PHP-фреймворков.

До его появления каждый фреймворк представлял HTTP-запросы и ответы по-своему, что осложняло перенос middleware и делало практически невозможным создание взаимозаменяемых HTTP-компонентов (клиентов, роутеров, фильтров) между разными стеками.

Также отсутствовали единые интерфейсы для потоков, заголовков и других элементов HTTP-сообщений.

PSR-7 ввёл унифицированную модель HTTP-сообщений и набор интерфейсов для основных сущностей:

\begin{itemize}
    \item \texttt{Request};
    \item \texttt{Response};
    \item \texttt{Stream};
    \item \texttt{UploadedFile};
    \item \texttt{URI}.
\end{itemize}

Практическим следствием стандарта стало развитие переносимых библиотек и middleware-слоя.

В экосистеме закрепились PSR-7-совместимые реализации (например Slim 3 \cite{slim3} и Zend Diactoros \cite{zenddiactoros}), а крупные фреймворки начали предоставлять адаптеры и мосты: Symfony добавил PSR-7-бриджи \cite{symfonypsr7bridges}, а Laravel поддержал совместимость на уровне интеграций \cite{laravelpsr7compatibility}.

PSR-7 также подготовил почву для дальнейшей стандартизации middleware-контрактов в PSR-15 \cite{psr15standard}.

% Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из наиболее значимых изменений за всё время развития экосистемы PHP-фреймворков.

% \subsubsection{Причины}

% До PSR-7:

% \begin{itemize}
%     \item Каждый фреймворк представлял HTTP-запрос/ответ по-своему.
%     \item Невозможно было переносить \texttt{middleware}.
%     \item Невозможно было использовать один и тот же HTTP-клиент или роутер между фреймворками.
%     \item Не существовало общего интерфейса потоков \texttt{streams}, \texttt{cookies}, \texttt{headers}.
% \end{itemize}

% \subsubsection{Принятое решение}

% PSR-7 создал единый интерфейс для:

% \begin{itemize}
%     \item \texttt{Request}.
%     \item \texttt{Response}.
%     \item \texttt{Stream}.
%     \item \texttt{UploadedFile}.
%     \item \texttt{URI}.
% \end{itemize}

% Это впервые позволило библиотекам работать независимо от фреймворка.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item Появление Slim 3 \cite{slim3}, Zend Diactoros \cite{zenddiactoros}, Guzzle PSR-7 clients \cite{guzzlepsr7clients}.
%     \item Появление кросс-фреймворковых \texttt{middleware}.
%     \item Symfony добавил PSR-7-бриджи \cite{symfonypsr7bridges}.
%     \item Laravel адаптировал совместимость на уровне интеграций \cite{laravelpsr7compatibility}.
% \end{itemize}

% PSR-7 \cite{psr7standard} стал фундаментом для PSR-15 \cite{psr15standard} и новой культуры \texttt{middleware} в PHP.

\subsection{PSR-11 и унификация DI-контейнеров (2017)}


Ещё одной ключевой проблемой PHP-фреймворков была несовместимость контейнеров зависимостей: Laravel, Symfony и Zend имели разные API, из-за чего библиотеки не могли запрашивать зависимости абстрактно и переносимо.

PSR-11 \cite{psr11standard} ввёл минимальный общий контракт контейнера — два интерфейса:

\begin{itemize}
    \item \texttt{ContainerInterface};
    \item \texttt{NotFoundExceptionInterface}.
\end{itemize}

Это позволило библиотекам и компонентам требовать доступ к контейнеру зависимостей без привязки к конкретному фреймворку.

В результате DI стал общеэкосистемным механизмом (а не «внутренней особенностью» отдельных фреймворков), снизилась фрагментация пакетов и упростилось создание переносимых компонентов, которым достаточно соблюдения PSR-11.

% Ещё одной ключевой проблемой PHP-фреймворков была несовместимость контейнеров зависимостей.

% \subsubsection{Причины}

% До PSR-11:
% \begin{itemize}
%     \item Каждый фреймворк имел собственный DI.
%     \item Пакеты не могли объявлять зависимости абстрактно.
%     \item Невозможно было использовать библиотеку, требующую объект из контейнера другого фреймворка.
% \end{itemize}

% Контейнеры Laravel, Symfony, Zend имели разные API.

% \subsubsection{Принятое решение}

% PSR-11 ввёл два интерфейса:

% \begin{itemize}
%     \item \graybox{ContainerInterface}.
%     \item \graybox{NotFoundExceptionInterface}.
% \end{itemize}

% Разработчики библиотек получили способ запрашивать зависимости без привязки к конкретному фреймворку.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item DI стал общим архитектурным механизмом, а не «особенностью» конкретного фреймворка.
%     \item \graybox{Middleware}-компоненты стали переносимыми.
%     \item Снизилась фрагментация библиотек.
% \end{itemize}

% PSR-11 \cite{psr11standard} способствовал развитию переносимых компонентов и библиотек, которым требуется доступ к контейнеру зависимостей без привязки к конкретному фреймворку.

\subsection{PSR-15 и middleware-архитектура (2017–2018)}

После появления PSR-7 \cite{psr7standard} стало возможным стандартизировать не только представление HTTP-сообщений, но и саму модель обработки запросов через цепочки middleware.

До PSR-15 \cite{psr15standard} разные фреймворки использовали несовместимые подходы (например, HttpKernel в Symfony и собственные middleware/фильтры в Laravel), а зрелая middleware-архитектура была характерна лишь для части стеков (Slim \cite{slim4}, Zend Expressive/Mezzio \cite{zendexpressive}).

PSR-15 \cite{psr15standard} закрепил два базовых контракта:

\begin{itemize}
    \item \texttt{MiddlewareInterface};
    \item \texttt{RequestHandlerInterface}.
\end{itemize}

Это приблизило PHP к распространённой в других экосистемах модели middleware-цепочек (Rack в Ruby, WSGI в Python, Connect в Node.js).

Практически стандарт ускорил развитие переносимых \texttt{middleware} и позволил middleware-ориентированным фреймворкам (например Mezzio \cite{zendexpressive} и Slim 4 \cite{slim4}) опираться на единый интерфейс.

Symfony и Laravel сохранили свои внутренние модели, но получили возможность совместимости через адаптеры и мосты \cite{symfonypsr7bridges, laravelpsr7compatibility}.

В итоге middleware стала центральной архитектурной единицей для многих PHP-приложений.

% После PSR-7 \cite{psr7standard} стало возможно стандартизировать поведение обработки запросов.
% Это позволило создать цепочки \texttt{middleware}.

% \subsubsection{Причины}

% Лишь некоторые фреймворки (Slim \cite{slim4}, Zend Expressive \cite{zendexpressive}) имели развитую \texttt{middleware}-модель.
% Symfony использовал HttpKernel, Laravel использовал фильтры и \texttt{middleware}, но их интерфейсы были несовместимы.

% \subsubsection{Принятое решение}

% PSR-15 \cite{psr15standard} определил:

% \begin{itemize}
%     \item \graybox{MiddlewareInterface}.
%     \item \graybox{RequestHandlerInterface}.
% \end{itemize}

% Это дало PHP ту же модель, что и:
% \begin{itemize}
%     \item Rack (Ruby).
%     \item WSGI (Python).
%     \item Connect (Node.js).
% \end{itemize}

% \subsubsection{Результаты}

% \begin{itemize}
%     \item Expressive / Mezzio (Zend → Laminas) стал первым PSR-15-first фреймворком \cite{zendexpressive}.
%     \item Slim 4 полностью перешёл на PSR-15 \cite{slim4}.
%     \item Symfony HttpKernel получил адаптеры \cite{symfonypsr7bridges}.
%     \item Laravel сохранил собственный контракт, но стал совместим через адаптеры \cite{laravelpsr7compatibility}.
% \end{itemize}

% Middleware стала центральной архитектурной единицей PHP-приложений.

\subsection{Влияние PHP 7 и PHP 8 на архитектуру фреймворков}

\subsubsection{PHP 7 (2015)}

\begin{itemize}
    \item Существенный прирост производительности по сравнению с PHP 5.x.
    \item Строгая модель ошибок (движение от предупреждений к исключениям).
    \item Scalar type hints, return types.
\end{itemize}

\subsubsection{PHP 8 (2020)}

\begin{itemize}
    \item Union types.
    \item Attributes.
    \item Match.
    \item JIT.
    \item Улучшенная типобезопасность.
\end{itemize}

\subsubsection{Результаты для фреймворков}

\begin{itemize}
    \item Symfony 3/4 \cite{symfonydependencyinjection} переписали DI-контейнер под строгую типизацию.
    \item Laravel \cite{laraveldocs} стал массово переходить к типизированным сигнатурам.
    \item Появилась культура строгих DTO, Value Objects, Immutable объектов.
    \item Фреймворки сократили магию и усилили контрактность API.
\end{itemize}

Типизация стала центральным архитектурным трендом 2020-х годов.

\subsection{Symfony: эволюция компонентной модели}

Symfony стал главным драйвером стандартизации.

\subsubsection{Основные изменения}

\begin{itemize}
    \item Переход от «полного фреймворка» к компонентам \cite{fabpot2012symfonycomponents} (HttpFoundation, EventDispatcher, Console, Routing).
    \item Адаптация архитектуры под PSR-7/PSR-11 \cite{symfonypsr7bridges, psr11standard}.
    \item Внедрение autowiring и автоконфигурации.
    \item Появление Symfony Flex как современного пакета приложений.
\end{itemize}
\subsubsection{Результаты}

Компонентная модель Symfony привела к тому, что многие проекты начали использовать отдельные компоненты Symfony как «строительные блоки» независимо от полного фреймворка. Это усилило тенденцию к стандартной инфраструктуре вне ядра языка: такие компоненты, как HttpKernel и EventDispatcher, стали де-факто архитектурными ориентирами для построения расширяемых приложений и библиотек, включая экосистему Laravel \cite{laraveldocs}.

\subsection{Laravel: эволюция DX и влияние стандартов}

Laravel \cite{laraveldocs} (2011) в 2015–2025 годах закрепился как фреймворк, ориентированный на удобство разработки (DX-first), единообразие API и практики convention over configuration, что сделало его особенно привлекательным для массовой разработки прикладных веб-систем.

В период 2015–2025:

\subsubsection{Основные изменения}

\begin{itemize}
    \item Переход на PSR-4, Composer и частично PSR-11.
    \item Внедрение middleware-модели совместимой с PSR-15.
    \item Адаптация к PHP 7/8 (типизация, атрибуты).
    \item Появление Horizon, Octane, Sail, Pint — инфраструктурных компонентов.
    \item Более строгая структура маршрутизации и DI.
\end{itemize}

\subsubsection{Результаты}

Laravel \cite{laraveldocs} стал «массовым воплощением» стандартизированной экосистемы PHP:

\begin{itemize}
    \item Он интегрирует PSR-совместимые библиотеки.
    \item Служит входной точкой для новых разработчиков.
    \item Влияет на индустриальные практики (DX, миграции, Eloquent как ORM-эталон).
\end{itemize}


\section{Отвергнутые и отложенные изменения}

Как и в случае с другими зрелыми технологиями, процесс стандартизации PHP-фреймворков сопровождался многочисленными предложениями, не вошедшими в финальные версии PSR-стандартов или отложенными на неопределённый срок.

Эти обсуждения позволяют понять, какие архитектурные решения были сочтены слишком узкими, слишком рискованными или концептуально несовместимыми с направлением развития экосистемы.

Ниже рассмотрены наиболее значимые инициативы, не приведшие к формированию стандарта.

\subsection{Несостоявшийся PSR для маршрутизации (Router PSR)}

Одним из регулярно поднимаемых предложений в рассылках PHP-FIG \cite{figrouterdiscussion} начиная с 2015 года было создание стандарта для роутинга HTTP-запросов.

\subsubsection{Причины появления инициативы}

Фреймворки использовали разные архитектуры маршрутов:

\begin{itemize}
    \item Laravel применяет декларативную синтаксическую модель (fluent API) \cite{laravelrouting}.
    \item Symfony использует аннотации, YAML и PHP-конфигурации \cite{symfonyrouting}.
    \item Slim и Mezzio строят маршрутизацию вокруг middleware \cite{slimrouting}.
    \item FastRoute — чисто функциональная библиотека без привязки к фреймворку \cite{fastroute}.
\end{itemize}

Отсутствие общего интерфейса приводило к невозможности создать:

\begin{itemize}
    \item Единый набор middleware для маршрутизации.
    \item Универсальные инструменты тестирования маршрутов.
    \item Переносимые роутинговые DSL.
\end{itemize}

\subsubsection{Причины отказа}
В обсуждениях FIG (2016–2018) было выявлено несколько проблем:

\subsubsection*{Различие моделей маршрутизации}
Одни фреймворки используют controller-based архитектуру (Laravel \cite{laravelrouting}, Symfony \cite{symfonyrouting}), другие (например Slim \cite{slimrouting}, Mezzio) используют middleware-based архитектуру.
Приведение этих моделей к единому интерфейсу оказалось практически невозможным.

\subsubsection*{Слишком высокий уровень абстракции}
Любой интерфейс становился либо:
\begin{itemize}
    \item Слишком низкоуровневым (и не решал задачи).
    \item Или слишком высоким.
\end{itemize}
\subsubsection*{Стандарт рисковал закрепить устаревший подход}
FIG избегает «Навязывать» архитектурные решения, чтобы не мешать инновациям.

\subsubsection*{Итог}
Инициатива была закрыта как слишком сложная и недостаточно универсальная.
Разработчики договорились, что роутинг останется частью каждого фреймворка, а интеграции будут строиться через PSR-7 \cite{psr7standard} и PSR-15 \cite{psr15standard}.

\subsection{Попытка создать PSR для ORM и абстракции работы с базами данных}

Регулярно обсуждалось создание стандарта для доступа к данным аналога JDBC для Java.
Попытки разработать единый интерфейс для ORM поднимались в рассылке PHP-FIG с 2014 по 2020 год \cite{figormdiscussion}.

\subsubsection*{Мотивация}

\begin{itemize}
    \item Множество несовместимых ORM: Doctrine ORM \cite{doctrineorm}, Eloquent ORM \cite{eloquentorm}, Propel \cite{propelorm}, RedBeanPHP \cite{redbeanphp}.
    \item Попытки создать стандартный QueryBuilder или EntityManager обсуждались с 2014 по 2020 год.
\end{itemize}


\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разные философии данных.
    \begin{itemize}
        \item Doctrine — ориентирована на DDD и Unit of Work.
        \item Eloquent — ActiveRecord и stateful-модель.
        \item Propel — XML-генерация моделей.
        \item RedBean — динамические схемы.
    \end{itemize}
    \item Разработчики ORM не готовы к унификации.\\
    Doctrine имеет строгую архитектуру, Laravel — гибкую, Eloquent использует «магические» свойства.
    \item Большая часть индустрии предпочитает свободу.\\
    FIG не хотел повторить опыт Java EE, где стандарты замедляли эволюцию ORM.
\end{itemize}

\subsubsection*{Итог}

PSR для ORM был признан нежизнеспособным.


\subsection{PSR-14 (Event Dispatcher): стандарт, который останется частичным}
PSR-14 \cite{psr14standard} был принят в 2019 году, но его разработка сопровождалась огромным количеством противоречий в рассылках PHP-FIG \cite{figpsr14discussion}.

\subsubsection*{Проблемы}
\begin{itemize}
    \item Фреймворки используют разные event models.
    \begin{itemize}
        \item Symfony: синхронный диспетчер событий, на основе объектных слушателей \cite{symfonyevents}.
        \item Laravel: разделение событий и слушателей + очередь + broadcast \cite{laravalevents}.
        \item Zend Framework: агрегаторы событий \cite{zendEventManager}.
    \end{itemize}
    Найти общую модель оказалось крайне трудно.
    \item Глубокие различия в семантике слушателей.\\
    Например, прекращение обработки событий отсутствует во многих системах.
    \item Слишком узкий охват стандарта.\\
    PSR-14 определяет слишком абстрактный интерфейс:
    \begin{lstlisting}[language=php]
    interface EventDispatcherInterface {
        public function dispatch(object $event): object;
    }
    \end{lstlisting}
\end{itemize}

\subsubsection*{Итог}
PSR-14 принят, но в экосистеме остаётся «вторичным» стандартом.
Существенная часть сообществ его игнорирует.

\subsection{Попытка создания PSR для валидаторов и форм}
Это обсуждение велось эпизодически с 2016 по 2021 годы \cite{figvalidationdiscussion}.

\subsubsection*{Мотивация}
\begin{itemize}
    \item Symfony Form + Validator имеют сложную, но зрелую модель \cite{symfonyform, symfonyvalidator}.
    \item Laravel Validation — декларативная модель со строковыми правилами \cite{laravelvalidation}.
    \item Respect/Validation — функциональная библиотека \cite{respectvalidation}.
\end{itemize}
Наличие множества несовместимых подходов порождало предложение создать переносимый стандарт.

\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разный уровень абстракции.
    \item Слишком разный DSL.\\
    Сравните:
    \begin{itemize}
        \item \graybox{'required|min:6'} (Laravel),
        \item \graybox{new Length(['min'=>6])} (Symfony),
        \item \graybox{v::stringType()->length(6)} (Respect).
    \end{itemize}
    \item Нежелание ограничивать инновации.\\
    Фреймворки активно экспериментируют со схемами данных.
\end{itemize}

\subsubsection*{Итог}
PSR для валидаторов и форм был признан нежизнеспособным.


\subsection{Споры вокруг PSR-18 (HTTP Client)}

PSR-18 \cite{psr18standard} был принят в 2019 году, но с серьёзными дискуссиями \cite{figpsr18discussion}.

\subsubsection*{Причины споров}

\begin{itemize}
    \item Разные модели ошибок (исключения vs error responses).
    \item Различия в реализации Guzzle \cite{guzzlehttp}, HTTPlug \cite{httplug}, Symfony HttpClient \cite{symfonyhttpclient}.
    \item Споры о синхронности vs асинхронности.
\end{itemize}

Некоторые разработчики хотели:

\begin{itemize}
    \item Асинхронный интерфейс (в стиле Promise).
    \item Unified Streaming API.
    \item Поддержку cancellation.
\end{itemize}

FIG решил ограничиться минимальным синхронным интерфейсом, что вызвало критику, но позволило стандартизировать общие ожидания.

\subsubsection*{Итог}

Стандарт был принят как «минимально необходимый», а остальные аспекты намеренно не стандартизированы.

\subsection{Предложение о расширении PSR-11 (унифицированная конфигурация контейнера)}

Иногда обсуждался стандарт для \cite{figpsr11expansion}:

\begin{itemize}
    \item Регистрации сервисов.
    \item Определения параметров.
    \item Описания factories.
\end{itemize}

Это сделало бы DI-контейнеры полностью совместимыми.

\subsubsection*{Причины отказа}

\begin{itemize}
    \item Разные модели конфигурации контейнера.
    \begin{itemize}
        \item Symfony использует YAML/PHP/XML \cite{symfonydependencyinjection}.
        \item Laravel использует bindings и closures \cite{laravelcontainer}.
        \item Laminas: Массивы-конфигурации \cite{laminasdi}.
    \end{itemize}
    Невозможно привести к общему знаменателю.
    \item Опасение закрепления устаревших подходов
    Стандартизация могла заморозить развитие DI.
\end{itemize}

\subsubsection*{Итог}
PSR-11 \cite{psr11standard} остался минималистичным.

\section{Заключение}

За период 2015–2025 годов экосистема PHP-фреймворков претерпела глубокую трансформацию, в результате которой веб-разработка на PHP фактически перешла от фрагментированного набора несовместимых архитектур к единому технологическому пространству, основанному на стандартах и переносимых компонентах.

Ключевую роль в этом процессе сыграли стандарты PHP-FIG (PSR-4, PSR-7, PSR-11, PSR-15), Composer и переход языка к строгой модели типизации в версиях PHP 7 и 8.

Эти изменения оказали системное влияние как на внутренние архитектуры фреймворков, так и на методологию разработки приложений.

Принятие PSR-4 и Composer стало отправной точкой для унификации структуры проектов, что позволило разрушить жёсткие границы между экосистемами разных фреймворков.

Стандартизация HTTP-модели (PSR-7) и middleware-контрактов (PSR-15) сформировала общий слой interoperability, дав толчок развитию кросс-фреймворковых библиотек и middleware-стека.

PSR-11 обеспечил совместимость контейнеров зависимостей, благодаря чему переносимость сервисов и компонентов значительно увеличилась.

Совокупно эти стандарты сформировали основу современной PHP-инфраструктуры, в которой логика приложения теперь отделена от конкретного фреймворка.


Наряду со стандартами FIG значительное влияние оказали изменения в самом языке: строгая типизация, исключительная модель ошибок, увеличение производительности PHP 7, а также атрибуты и JIT-компиляция в PHP 8.

Эти изменения стимулировали фреймворки к переработке внутренних механизмов и улучшению архитектурных практик.

Symfony в этот период окончательно утвердился как компонентный фреймворк, определяющий технические ориентиры для всей PHP-индустрии; Laravel, напротив, стал укреплять свою позицию как высокоуровневый фреймворк, фокусирующийся на удобстве разработки и интеграции с современными DevOps-практиками.

Современные версии обоих фреймворков демонстрируют высокую степень согласованности с PSR-стандартами и активно используют возможности нового PHP.


Особое значение имеют технологии и стандарты, которые не были приняты.

Несостоявшийся PSR для роутинга, отсутствие стандарта для ORM, частичная применимость PSR-14 — всё это демонстрирует, что стандартизация не может и не должна охватывать все аспекты PHP-экосистемы.

Слишком разнообразные архитектуры и различные философии разработки делают некоторые стандарты непрактичными.

В этом смысле отказ от стандартизации отдельных областей оказался не менее ценным, чем успешные инициативы: он позволил индустрии сохранить гибкость и конкурентное разнообразие.

В целом, архитектурная эволюция PHP-фреймворков в 2015–2025 годах может быть охарактеризована как движение к стандартизации на ключевых уровнях абстракции при сохранении свободы в реализации высокоуровневых концепций.

Этот период стал временем консолидации и зрелости: фреймворки перестали быть самостоятельными островами и стали частями единой экосистемы, в которой интерфейсы важнее реализаций, а архитектура — важнее конкретных технологий.

PHP, часто считавшийся устаревающим, за это десятилетие подтвердил свою жизнеспособность, адаптировавшись к современным требованиям производительности, типобезопасности и модульности.

Эта трансформация стала возможной благодаря открытому процессу разработки, публичным обсуждениям в PHP-FIG и активной роли сообществ Symfony и Laravel.

Таким образом, изменения 2015–2025 годов можно считать одним из самых успешных этапов в истории PHP: язык и его фреймворки не только сохранили позиции, но и стали примером того, как открытая стандартизация и согласованные архитектурные решения способны преобразовать зрелую технологию в соответствующую требованиям нового времени.
\setmonofont{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{programming_history}

\end{document}
