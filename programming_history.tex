% !TEX TS-program = xelatex
% !BIB program = bibtex
% !TeX spellcheck = ru_RU

% About magic macros see also
% https://tex.stackexchange.com/questions/78101/

% По умолчанию используется шрифт 14 размера.
% Если Вы не влезаете в лимит страниц и нужен 12-й шрифт,
% то уберите опцию [14pt]

\documentclass[14pt, russian]{matmex-diploma-custom}
\usepackage{listings}
\usepackage{xcolor}

\newcommand{\graybox}[1]{%
  \colorbox{lightgray}{\strut #1}%
}


\input{preamble.tex}

\begin{document}

\input{programming_history_title.tex}
\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\pagebreak

\section{Введение}
\thispagestyle{withCompileDate}
PHP играет важную роль в веб-разработке на протяжении почти трёх десятилетий, оставаясь одним из наиболее распространённых серверных языков.

Согласно статистике W3Techs по состоянию на 1 ноября 2025 года, PHP используется в 72.9\% веб-сайтов с определённым языком серверной части \cite{W3Techs}.

Широкая доступность хостинга и относительно низкий порог входа сделали PHP \cite{phplatest} основой для множества систем управления контентом и прикладных веб-решений.

Однако, устойчивость языка и его экосистемы на протяжении длительного периода в значительной степени связана с развитием общих архитектурных практик и стандартов, которые определили индустрию PHP \cite{phplatest}-разработки.

В начале 2000-х годов в ответ на растущую сложность веб-приложений начали формироваться первые полнофункциональные PHP-фреймворки.

CakePHP (2005) \cite{cakephp2005announce}, Symfony (2005) \cite{symfony2005release} и CodeIgniter (2006) \cite{codeigniter2006announce} заложили основы MVC-подхода и упорядочили разработку веб-приложений в условиях отсутствия единых стандартов.

Однако по мере усложнения проектов стало очевидно, что решения того периода сталкиваются с рядом системных ограничений, включая непрозрачную архитектуру, несовместимость компонентов, отсутствие унифицированных интерфейсов и недостаточную тестируемость.

В течение следующего десятилетия (2005–2015) PHP \cite{phplatest}-стек претерпел значительные изменения. Это было связано с разработкой PHP-FIG \cite{phpfig2009charter} и ряда стандартов PSR \cite{psr0standard}, появлением Composer \cite{seldaek2012composer}, унификацией HTTP-модели \cite{psr7standard}, распространением принципов DI \cite{psr11standard} и архитектурой middleware \cite{psr15standard}.

Тем не менее, между 2015 и 2025 годами произошли наиболее значительные структурные изменения в PHP-фреймворках. Эти изменения радикально изменили архитектурные решения, принципы проектирования и практики масштабирования.

Эти преобразования охватывали выход PHP 7 \cite{php7rfc2015}, внедрение массовой типизации и переход к строгой модели обработки ошибок, реорганизацию Symfony \cite{symfony2005release} в рамках компонентной архитектуры, стремительный развитие Laravel \cite{laravel2011announce}, а также упадок Zend \cite{zendframework2006announce} Framework и его последующую трансформацию в проект Laminas.

Цель настоящей работы — провести комплексный анализ ключевых архитектурных и технологических изменений, произошедших в PHP-фреймворках в период с 2015 по 2025 годы. В рамках исследования предполагается выявить причины указанных изменений, оценить эффективность принятых техническиатурных решений, а также определить, какие концепции и подходы были отвергнуты или модифицированы в ходе профессиональных дискуссий.

Для достижения поставленных целей используются следующие источники: материалы рассылок PHP-FIG \cite{phpfig2009charter}, предложения RFC Internals PHP, официальные публикации Symfony \cite{symfony2005release} и Laravel \cite{laravel2011announce}, дискуссии GitHub о стандартах Composer и PSR, а также доклады разработчиков, представленные на профильных конференциях — в частности, SymfonyCon \cite{symfonycon} и Laracon \cite{laracon}.

Таким образом, в статье рассматривается не только эволюция отдельных фреймворков, но и более широкий процесс формирования профессиональной PHP-экосистемы, в которой технологические инновации выступают в качестве ключевого фактора развития.

\section{Особенности развития PHP-экосистемы до стандартизации (до 2015 года)}

К 2015 году промышленная разработка на PHP \cite{phplatest} характеризовалась двойственным положением. С одной стороны, язык сохранял широкое распространение и технологическую зрелость как платформа для веб-приложений, обусловленную простотой развёртывания, высокой доступностью хостинговых решений и устойчивой обратной совместимостью. С другой стороны, PHP-экосистема страдала от существенных архитектурных ограничений, вызванных отсутствием унифицированных стандартов проектирования и низкой совместимостью между ключевыми компонентами. Это приводило к увеличению совокупной стоимости сопровождения проектов, а также замедляло темпы развития как сторонних библиотек, так и фреймворков.
\subsection{Отсутствие единых интерфейсов}
До появления PHP-FIG \cite{phpfig2009charter} в экосистеме PHP отсутствовали общепринятые технические соглашения по ключевым аспектам разработки, включая:

\begin{itemize}
    \item организацию структуры каталогов;
    \item механизмы автоматической загрузки классов;
    \item унифицированное представление HTTP-запросов и ответов;
    \item интерфейсы контейнеров внедрения зависимостей (DI);
    \item стандартные контракты для middleware и модель обработки HTTP-запросов.
\end{itemize}

В результате каждый из ведущих фреймворков, включая Symfony \cite{symfony2005release}, Zend \cite{zendframework2006announce}, CakePHP \cite{cakephp2005announce} и CodeIgniter \cite{codeigniter2006announce}, реализовывал собственные, зачастую несовместимые подходы к решению этих задач. Это привело к эффекту фрагментации экосистемы PHP, при котором фреймворки и библиотеки развивались как изолированные подсистемы с ограниченной совместимостью.

Например, Symfony \cite{symfony2005release} применял собственный автозагрузчик и строгие соглашения об именовании, тогда как Zend предлагал иную структуру каталогов. Многие сторонние библиотеки того времени подключались вручную и не содержали формализованных метаданных о зависимостях, что исключало автоматизированное управление ими.

Такая ситуация приводила к высокой степени связанности между фреймворками и их компонентами. Интеграционные решения часто основывались на неформализованных соглашениях и паттернах, а изменения в деталях реализации нарушали обратную совместимость.

\subsection{Проблема совместимости и отсутствие компонентов повторного использования}

Ключевая проблема данного периода заключалась в невозможности использовать одну и ту же библиотеку в разных фреймворках. Такие распространённые компоненты, как HTTP-клиенты, инструменты логгирования и шаблонизаторы, были тесно интегрированы в архитектуру конкретных фреймворков и зависели от их внутренних соглашений, стилей кодирования и точек расширения. Попытки переноса подобных решений между проектами зачастую приводили к конфликтам, обусловленным различиями в API, структуре кода и механизмах интеграции.

Symfony \cite{symfony2005release} стал одним из первых фреймворков, предпринявших системную попытку преодолеть эту фрагментацию за счёт внедрения компонентного подхода \cite{fabpot2012symfonycomponents} (начиная с Symfony 2 \cite{symfony2011release}), однако в отсутствие общепринятых отраслевых стандартов такой подход оставался локальным решением, которое не обеспечивало гарантированной совместимости и стабильности интеграций.

\subsection{Отсутствие стандартизированной модели HTTP}

Одним из ключевых технологических ограничений PHP-экосистемы до появления общих стандартов являлось отсутствие унифицированного представления основных HTTP-компонентов: запроса, ответа, а также их атрибутов, заголовков и потоков данных.

Каждый из ведущих фреймворков реализовывал собственные, несовместимые между собой классы для работы с HTTP-слоем:

\begin{itemize}
    \item HttpFoundation \cite{symfonyhttpfoundation} в Symfony;
    \item Http \cite{zendhttp} (Request / Response) в Zend;
    \item Http \cite{slimhttp} в Slim;
    \item Собственные реализации в CakePHP \cite{cakephphttp}.
\end{itemize}

Такая фрагментация затрудняла разработку взаимозаменяемых middleware-компонентов, снижала переносимость кода между проектами и препятствовала созданию единых решений для HTTP-клиентов, фильтров и других инструментов обработки запросов.

Глубина проблемы подтверждается продолжительностью обсуждения стандарта PSR-7 \cite{psr7standard} в рабочих группах PHP-FIG: дискуссии по его формулировке велись почти три года. Это свидетельствует о фундаментальном характере задачи стандартизации HTTP-интерфейсов для всей экосистемы.

\subsection{Отсутствие единых правил для автозагрузки и управления зависимостями}

До появления Composer \cite{seldaek2012composer} и принятия стандарта PSR-4 \cite{psr4standard} (2013–2014 гг.) подключение сторонних библиотек в PHP-проектах, как правило, осуществлялось вручную с использованием конструкций \texttt{require/include}. Декларативное управление зависимостями фактически отсутствовало, а распространение кода происходило преимущественно через архивы в формате ZIP или посредством системы PEAR.

Отсутствие унифицированных правил автозагрузки классов обусловливало жёсткую привязку к структуре каталогов и способствовало частым конфликтам версий библиотек.

Ситуация принципиально изменилась с появлением Composer \cite{seldaek2012composer}, который ввёл централизованный и декларативный механизм управления зависимостями и автозагрузкой. Однако его широкое внедрение в промышленную разработку началось лишь в 2014–2015 гг. Этот период стал отправной точкой для изменений, анализируемых в последующих разделах.

\subsection{Проблемы тестируемости и внедрения зависимостей}
До принятия стандарта PSR-11 \cite{psr11standard} (Container Interface) каждый из ведущих PHP-фреймворков реализовывал собственный контейнер внедрения зависимостей (DI-контейнер), причём эти реализации не были совместимы между собой. К числу наиболее распространённых решений относились:


\begin{itemize}
    \item Symfony Dependency Injection \cite{symfonydependencyinjection};
    \item Laravel Container \cite{laravelcontainer};
    \item Zend Service Manager \cite{zendservicemanager};
    \item Pimple \cite{pimple}.
\end{itemize}

Отсутствие унифицированного интерфейса контейнера создавало ряд системных ограничений:

\begin{itemize}
    \item затрудняло разработку многократно используемых пакетов, не привязанных к конкретному фреймворку;
    \item делало невозможным перенос middleware-компонентов и других сервисов между проектами;
    \item замедляло развитие архитектур, основанных на принципах внедрения зависимостей и их управления.
\end{itemize}

Таким образом, архитектура внедрения зависимостей представляла собой одну из ключевых проблем экосистемы PHP, решение которой стало возможным лишь в последние 10 лет (2015–2025) в ходе стандартизации — в частности, с принятием PSR-11 \cite{psr11standard}.

\section{Развитие стандартов и архитектурных решений в экосистеме PHP (2015–2025)}

Период 2015–2025 годов стал для PHP-фреймворков этапом глубокой технологической трансформации.

В предшествующее десятилетие (2005–2015) были сформулированы и заложены фундаментальные концепции, определившие дальнейшее развитие экосистемы: создание PHP-FIG \cite{phpfig2009charter}, появление менеджера зависимостей Composer \cite{seldaek2012composer}, а также разработка PSR, первых стандартов PHP \cite{psr0standard}, включая PSR-4 \cite{psr4standard}, PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard}, PSR-15 \cite{psr15standard}.

Однако качественный переход к современной архитектуре веб-приложений начался лишь после выхода PHP 7 \cite{php7rfc2015} и  широкого внедрения ключевых стандартов — PSR-7 \cite{psr7standard}, PSR-11 \cite{psr11standard} и PSR-15 \cite{psr15standard}.

В данном разделе рассматриваются ключевые архитектурные изменения, произошедшие в указанный период, анализируются предпосылки их возникновения и оценивается их влияние на эволюцию PHP-экосистемы.

\subsection{Composer как фундамент модернизации экосистемы}

Менеджер зависимостей Composer \cite{seldaek2012composer} был впервые выпущен в 2012 году, однако его широкое внедрение в PHP-экосистеме произошло в 2015–2017 гг. Именно в этот период подавляющее большинство фреймворков и сторонних библиотек перешли на декларативную модель управления зависимостями.

Как отмечалось выше, до внедрения Composer управление зависимостями оставалось фрагментированным и неформализованным, что создавало ряд проблем при сопровождении крупных проектов и осложняло архитектурную эволюцию фреймворков.

Composer предложил унифицированное решение, включавшее декларативное описание зависимостей с помощью \texttt{composer.json} \cite{composerJsonSchema}, стандартизированный механизм автозагрузки классов на основе PSR-4 \cite{psr4standard}, поддержку семантического версионирования (SemVer) \cite{semver} и централизованный репозиторий пакетов Packagist \cite{packagist}.

Благодаря этим инновациям архитектурная парадигма PHP-фреймворков трансформировалась: они перестали восприниматься как монолитные системы и стали рассматриваться как композиции слабосвязанных, автономных компонентов, пригодных к обособленному выбору, комбинированию и обновлению.

К началу 2020-х годов Composer фактически закрепился в качестве инфраструктурного стандарта PHP-экосистемы. Это привело к снижению привязки библиотек к конкретным фреймворкам, ускорению обмена компонентами между проектами и формированию устойчивой культуры разработки фреймворк-независимых пакетов, ориентированных на повторное использование.

% \subsubsection{Причины изменения:}
% До Composer \cite{seldaek2012composer} управление зависимостями основывалось на:
% \begin{itemize}
%     \item Ручном подключении файлов через \texttt{require} или \texttt{include}.
%     \item Распространении пакетов через \texttt{ZIP}-архивы или \texttt{PEAR}.
%     \item Отсутствии разрешения конфликтов версий.
% \end{itemize}

% Это приводило к «зависимостному аду» \cite{dependencyHellWikipedia} и мешало развитию фреймворков.

% \subsubsection{Принятое решение}

% Composer \cite{seldaek2012composer} ввёл:

% \begin{itemize}
%     \item файл \texttt{composer.json} \cite{composerJsonSchema} в качестве декларации зависимостей.
%     \item Автозагрузчик, основанный на PSR-4 \cite{psr4standard}.
%     \item Семантическое версионирование \cite{semver}.
%     \item Центральный репозиторий \texttt{Packagist} \cite{packagist}.
% \end{itemize}

% Философия Composer \cite{seldaek2012composer} повлияла на всю экосистему: фреймворки стали не «монолитами», а наборами компонентов, которые можно выбирать, комбинировать и обновлять независимо.


% \subsubsection{Результаты}
% \begin{itemize}
%     \item Исчезла жёсткая привязка библиотек к конкретным фреймворкам.
%     \item Появилось огромное количество независимых пакетов.
%     \item Разработчики получили прозрачное управление зависимостями.
% \end{itemize}
% Composer \cite{seldaek2012composer} стал фактическим стандартом и сделал возможным внедрение последующих PSR.
\subsection{Развитие PSR и их роль в архитектурной трансформации PHP-экосистемы}

Стандарты PSR, разрабатываемые в рамках PHP-FIG \cite{phpfig2009charter}, стали центральным инструментом преодоления архитектурной фрагментации PHP-экосистемы в период 2015–2025 годов. В отличие от ранних инициатив по унификации, ориентированных на внутреннюю архитектуру отдельных фреймворков, PSR-стандарты были направлены на установление минимальных, но строго определённых контрактов, обеспечивающих совместимость между фреймворками без навязывания конкретных реализаций.

Эта стратегия позволила сформировать общий архитектурный «язык», на котором могли взаимодействовать разнородные компоненты, независимо от их происхождения. Каждый из ключевых стандартов решал узкую, но критически важную проблему совместимости, при этом внося вклад в общую картину модульной и переносимой архитектуры.

В следующих подразделах рассматриваются наиболее влиятельные PSR-стандарты, сыгравшие решающую роль в трансформации PHP-экосистемы: их предпосылки, ключевые положения и архитектурные последствия.
\subsubsection{PSR-4 и единая модель автозагрузки (2015)}

Стандарт PSR-4 \cite{psr4standard} стал решающим этапом в переходе от фрагментированных, фреймворк-специфичных соглашений к единой и предсказуемой модели автозагрузки классов в PHP-экосистеме.

Его практическое значение особенно возросло в период 2015–2020 годов, когда основные фреймворки начали систематически приводить структуру каталогов и организацию пространств имён в соответствие с PSR-4 \cite{psr4standard}. Это, в свою очередь, предоставило менеджеру зависимостей Composer устойчивую основу для генерации стандартизированного автозагрузчика, совместимого с любым соответствующим пакетом.

До принятия PSR-4 \cite{psr4standard} каждый крупный фреймворк использовал собственные, несовместимые между собой правила сопоставления имён классов с путями к файлам. Такая фрагментация затрудняла интеграцию сторонних библиотек, увеличивала сложность сопровождения и негативно сказывалась на масштабируемости проектов.

В отличие от прежней ситуации, когда каждая платформа определяла собственные правила, PSR-4 \cite{psr4standard} формализовал два ключевых принципа: во-первых, строгое соответствие между пространствами имён и иерархией каталогов; во-вторых, возможность автоматической загрузки классов без необходимости использования конструкций \texttt{include} или \texttt{require}.

В результате значительно повысилась переносимость библиотек между проектами, а архитектура фреймворков стала более компонентной: сократилась доля проприетарного инфраструктурного кода, а уровень взаимной совместимости в экосистеме в целом существенно возрос.

% PSR-4 \cite{psr4standard} (2014) стал ключевым переходом от хаотичных соглашений к единообразной системе.

% Но именно в период 2015–2020, когда фреймворки начали массово переписывать внутренние структуры под PSR-4 \cite{psr4standard}.

% \subsubsection{Причины}
% До PSR-4 \cite{psr4standard}:
% \begin{itemize}
%     \item Каждый фреймворк имел собственные правила размещения классов.
%     \item Не было единообразных пространств имён.
%     \item Библиотеки не могли интегрироваться между собой.
% \end{itemize}


% \subsubsection{Принятое решение}
% PSR-4 \cite{psr4standard} определил:
% \begin{itemize}
%     \item Строгие правила сопоставления пространств имён с каталогами.
%     \item Автоматическую загрузку классов без ручных \texttt{include} или \texttt{require}.
% \end{itemize}

% \subsubsection{Результаты}
% \begin{itemize}
%     \item Библиотеки стали взаимозаменяемыми.
%     \item Фреймворки уменьшили собственный «клей» и стали ориентироваться на компоненты.
%     \item Composer \cite{seldaek2012composer} получил техническую основу для генерации стандартизированного автозагрузчика.
% \end{itemize}

% PSR-4 \cite{psr4standard} стал первым шагом к «общему грамматическому строю» всей экосистемы.


\subsubsection{PSR-7 и стандартизация HTTP-модели (2015)}

Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из ключевых факторов в эволюции архитектуры PHP-экосистемы.

До его принятия HTTP-запросы и ответы в каждом фреймворке реализовывались с использованием собственных, несовместимых между собой моделей. Это препятствовало переносу middleware-компонентов и делало практически невозможной разработку взаимозаменяемых HTTP-инструментов — таких как клиенты, маршрутизаторы или фильтры — между различными стеками фреймворков. Кроме того, отсутствовали унифицированные интерфейсы для потоков данных, заголовков и других элементов HTTP-сообщений.

PSR-7 \cite{psr7standard} устранил эту фрагментацию, предложив стандартизированную модель HTTP-сообщений и чётко определённый набор интерфейсов для основных сущностей: \texttt{Request}, \texttt{Response}, \texttt{Stream}, \texttt{UploadedFile} и \texttt{URI}.

Практическим следствием стандарта стало развитие middleware-компонентов и переносимых HTTP-библиотек. В экосистеме утвердились нативные PSR-7-совместимые реализации, такие как Slim 3 \cite{slim3} и Zend Diactoros \cite{zenddiactoros}. Крупные фреймворки также адаптировались к новой реальности: Symfony внедрил специализированные PSR-7-бриджи \cite{symfonypsr7bridges}, а Laravel обеспечил совместимость через интеграционные слои \cite{laravelpsr7compatibility}.

Таким образом, PSR-7 \cite{psr7standard} не только решил проблему фрагментации HTTP-интерфейсов, но и заложил архитектурную основу для последующей стандартизации — в частности, для разработки контрактов \texttt{middleware} в PSR-15 \cite{psr15standard}.

% Стандарт PSR-7 \cite{psr7standard} (HTTP Message Interface) стал одним из наиболее значимых изменений за всё время развития экосистемы PHP-фреймворков.

% \subsubsection{Причины}

% До PSR-7:

% \begin{itemize}
%     \item Каждый фреймворк представлял HTTP-запрос/ответ по-своему.
%     \item Невозможно было переносить \texttt{middleware}.
%     \item Невозможно было использовать один и тот же HTTP-клиент или роутер между фреймворками.
%     \item Не существовало общего интерфейса потоков \texttt{streams}, \texttt{cookies}, \texttt{headers}.
% \end{itemize}

% \subsubsection{Принятое решение}

% PSR-7 создал единый интерфейс для:

% \begin{itemize}
%     \item \texttt{Request}.
%     \item \texttt{Response}.
%     \item \texttt{Stream}.
%     \item \texttt{UploadedFile}.
%     \item \texttt{URI}.
% \end{itemize}

% Это впервые позволило библиотекам работать независимо от фреймворка.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item Появление Slim 3 \cite{slim3}, Zend Diactoros \cite{zenddiactoros}, Guzzle PSR-7 clients \cite{guzzlepsr7clients}.
%     \item Появление кросс-фреймворковых \texttt{middleware}.
%     \item Symfony добавил PSR-7-бриджи \cite{symfonypsr7bridges}.
%     \item Laravel адаптировал совместимость на уровне интеграций \cite{laravelpsr7compatibility}.
% \end{itemize}

% PSR-7 \cite{psr7standard} стал фундаментом для PSR-15 \cite{psr15standard} и новой культуры \texttt{middleware} в PHP.
\subsubsection{PSR-11 и унификация DI-контейнеров (2017)}
Ещё одной существенной проблемой PHP-экосистемы до стандартизации являлась несовместимость контейнеров внедрения зависимостей: такие фреймворки, как Laravel \cite{laraveldocs}, Symfony \cite{symfonydependencyinjection} и Zend Framework, реализовывали собственные, взаимно несовместимые API, что не позволяло сторонним библиотекам запрашивать зависимости абстрактно и переносимо.

Принятие стандарта PSR-11 \cite{psr11standard} устранило данный барьер, определив спецификацию контейнера в виде двух интерфейсов: \texttt{ContainerInterface} и \texttt{NotFoundExceptionInterface}.

Благодаря этому сторонние компоненты получили возможность взаимодействовать с DI-контейнером без привязки к конкретному фреймворку. В результате внедрение зависимостей трансформировалось из внутреннего механизма отдельных фреймворков в общую экосистемную практику. Это способствовало снижению фрагментации пакетов и упростило разработку переносимых компонентов, совместимость которых обеспечивается исключительно соответствием требованиям PSR-11 \cite{psr11standard}.

% Ещё одной ключевой проблемой PHP-фреймворков была несовместимость контейнеров зависимостей.

% \subsubsection{Причины}

% До PSR-11:
% \begin{itemize}
%     \item Каждый фреймворк имел собственный DI.
%     \item Пакеты не могли объявлять зависимости абстрактно.
%     \item Невозможно было использовать библиотеку, требующую объект из контейнера другого фреймворка.
% \end{itemize}

% Контейнеры Laravel, Symfony, Zend имели разные API.

% \subsubsection{Принятое решение}

% PSR-11 ввёл два интерфейса:

% \begin{itemize}
%     \item \graybox{ContainerInterface}.
%     \item \graybox{NotFoundExceptionInterface}.
% \end{itemize}

% Разработчики библиотек получили способ запрашивать зависимости без привязки к конкретному фреймворку.

% \subsubsection{Результаты}

% \begin{itemize}
%     \item DI стал общим архитектурным механизмом, а не «особенностью» конкретного фреймворка.
%     \item \graybox{Middleware}-компоненты стали переносимыми.
%     \item Снизилась фрагментация библиотек.
% \end{itemize}

% PSR-11 \cite{psr11standard} способствовал развитию переносимых компонентов и библиотек, которым требуется доступ к контейнеру зависимостей без привязки к конкретному фреймворку.

\subsubsection{PSR-15 и middleware-архитектура (2017–2018)}
После принятия стандарта PSR-7 \cite{psr7standard}, унифицировавшего представление HTTP-сообщений, стала возможной дальнейшая стандартизация самой модели обработки запросов через цепочки middleware.

До появления PSR-15 \cite{psr15standard} фреймворки применяли несовместимые подходы к организации middleware-слоя: так, Symfony использовал компонент HttpKernel, Laravel — собственные фильтры и middleware-механизмы, тогда как последовательная middleware-архитектура, основанная на цепочках обработчиков, была характерна лишь для отдельных стеков, таких как Slim \cite{slim4} и Zend Expressive (впоследствии Mezzio) \cite{zendexpressive}.

Стандарт PSR-15 \cite{psr15standard} формализовал два базовых интерфейса: \texttt{MiddlewareInterface} и \texttt{RequestHandlerInterface}.

Это приблизило PHP-экосистему к устоявшимся в других языках моделям обработки запросов через middleware-цепочки — таким как Rack (Ruby), WSGI (Python) и Connect/Express (Node.js).

Практическое значение PSR-15 \cite{psr15standard} заключалось в ускорении разработки переносимых middleware-компонентов и обеспечении единой основы для middleware-ориентированных фреймворков, включая Mezzio \cite{zendexpressive} и Slim 4 \cite{slim4}. Фреймворки с иной архитектурой, такие как Symfony и Laravel, сохранили свои внутренние модели, но обеспечили совместимость с PSR-15 посредством адаптеров и мостов \cite{symfonypsr7bridges, laravelpsr7compatibility}.

В результате \texttt{middleware} превратился в одну из ключевых архитектурных единиц проектирования современных PHP-приложений.





\subsection{Влияние PHP 7 и PHP 8 на архитектуру фреймворков}

Эволюция языка PHP в версиях 7 \cite{php7rfc2015} (2015) и 8 \cite{php8typingrfc2020} (2020) оказала фундаментальное воздействие на архитектурные основы современных PHP-фреймворков, инициировав переход от динамической, слабо типизированной модели к более строгой и предсказуемой парадигме проектирования. Ключевым сдвигом стало не просто ускорение выполнения кода или расширение возможностей, а изменение самой культуры взаимодействия компонентов: язык стал требовать от разработчиков — и, соответственно, от фреймворков — большей формальной точности, что напрямую отразилось на проектировании API, управлении зависимостями и организации внутренней логики приложений.

С выходом PHP 7 \cite{php7rfc2015} архитектура PHP-разработки начала кардинально меняться. Переход от нефатальных ошибок и предупреждений к строгой модели на основе исключений, а также появление скалярной типизации и возвращаемых типов позволили оформлять контракты между компонентами на уровне самого кода, а не в виде комментариев. Это побудило фреймворки отказываться от неявных соглашений и динамических зависимостей, которые ранее служили источником ошибок и снижали сопровождаемость. Интерфейсы стали проектироваться как строго типизированные контракты, в которых сигнатуры методов выражали не просто реализацию, а архитектурную спецификацию.

Особенно заметным стало влияние этих изменений на контейнеры внедрения зависимостей. Возможность управлять зависимости на основе типов, поддерживаемых автоматическим связыванием и строгими сигнатурами, позволила сократить объём конфигурационного кода и повысить прозрачность архитектуры.

Релиз PHP 8 \cite{php8typingrfc2020} усилил и закрепил эти тенденции, добавив важные механизмы, которые ещё больше повысили декларативность и явность архитектуры. Введение объединений (Union Types) устранило необходимость в избыточной проверке типов внутри методов и позволило точно описывать допустимые варианты входных и выходных данных. Атрибуты позволили перенести метаданные, ранее размещавшиеся в конфигурационных файлах или PHPDoc-аннотациях, непосредственно в тело кода, сделав маршрутизацию, сериализацию, валидацию и другие аспекты логики явными и локализованными. А выражение match, являясь типобезопасной и компактной альтернативой switch, также способствовало написанию более корректного и лаконичного кода.

В результате таких изменений в экосистеме фреймворков усилилось применение строгих архитектурных паттернов: получили широкое распространение Объекты передачи данных (DTO), Объекты-Значения (Value Objects) и неизменяемые структуры данных. Эти подходы, ранее считавшиеся излишне формальными для PHP-среды, стали практически применимыми благодаря возможностям типизации и предсказуемости поведения кода.

Крупнейшие фреймворки, такие как Symfony и Laravel \cite{laraveldocs}, адаптировались к этим изменениям, сохраняя свои особенности, но двигаясь в едином направлении. Symfony сосредоточился на максимальной интеграции с возможностями языка, усилив типобезопасность компонентов и оптимизировав контейнер зависимостей \cite{symfonydependencyinjection}, тогда как Laravel \cite{laraveldocs}, оставаясь ориентированным на удобство, постепенно сокращал использование неявной «магии» и усиливал контрактность своих API. В обоих случаях развитие самого языка стало не внешним обстоятельством, а внутренним драйвером архитектурной трансформации.

Таким образом, влияние PHP 7 \cite{php7rfc2015} и PHP 8 \cite{php8typingrfc2020} на фреймворки проявилось не в виде изолированных языковых нововведений, а как формирование новой дисциплины проектирования, ориентированной на явные контракты, модульность и формальную корректность. Эти изменения не только повысили надёжность и сопровождаемость PHP-приложений, но и сблизили экосистему с архитектурными практиками, принятыми в других современных серверных платформах, тем самым закрепив переход PHP от «скриптового» языка к стабильной среде для построения сложных, масштабируемых систем.


\subsection{Влияние Symfony на развитие компонентной модели в PHP}

Symfony оказал определяющее влияние на архитектурную трансформацию PHP-экосистемы, выступив не только в роли полноценного веб-фреймворка, но и в качестве поставщика универсальных инфраструктурных компонентов.

Этот переход от монолитной модели «полного фреймворка» к совокупности автономных, слабосвязанных компонентов \cite{fabpot2012symfonycomponents} — таких как HttpFoundation \cite{symfonyhttpfoundation}, EventDispatcher, Console \cite{symfonyconsole} и Routing \cite{symfonyrouting} — стал ответом на ключевые проблемы PHP-экосистемы. Компоненты разрабатывались как независимые библиотеки с чётко определёнными интерфейсами и минимальными внешними зависимостями, что обеспечило их применимость вне контекста самого Symfony. Подобный подход соответствовал инициативам PHP-FIG \cite{phpfig2009charterphpfig}, способствуя активной интеграции Symfony с отраслевыми стандартами, в частности с PSR-7 и PSR-11 \cite{symfonypsr7bridges, psr11standard}, и тем самым укрепляя совместимость на уровне фундаментальных абстракций.

Дальнейшее развитие архитектуры фреймворка сопровождалось внедрением механизмов автосвязывания (autowiring) \cite{symfonyautowiring} и автоконфигурации (auto-configuration), ставших возможными благодаря усилению типобезопасности и развитию рефлексии в PHP 7 и PHP 8. Эти механизмы позволили значительно сократить объём явной конфигурации, перенося информацию о структуре зависимостей непосредственно в сигнатуры классов. В результате архитектура приложений приблизилась к декларативной модели, в которой связи между компонентами становятся явными, предсказуемыми и верифицируемыми на этапе статического анализа, что снижает нагрузку при разработке и сопровождении масштабных систем.

Кульминацией компонентной культуры Symfony стало появление Symfony Flex — инфраструктурного решения, переосмыслившего процесс сборки приложения как динамическую композицию пакетов и конфигураций. Эта модель устранила необходимость в фиксированной структуре фреймворка и позволила разработчикам гибко конструировать приложения под конкретные задачи, используя только необходимые компоненты.

Таким образом, Symfony сформировал ядро инфраструктурной конвергенции в PHP-экосистеме, вне зависимости от языкового ядра, а его компонентная модель легла в основу современных подходов к разработке расширяемых, переносимых и стандартизированных систем.

\subsection{Laravel как проводник DX-практик в PHP-экосистеме}

Laravel \cite{laravelpopularity} в период 2015–2025 годов утвердился как ведущий фреймворк, ориентированный на максимальное удобство разработки и единообразие интерфейсов. В отличие от Symfony, Laravel \cite{laraveldocs} изначально был нацелен на снижение порога входа и унификацию практик прикладной разработки, что обусловило его широкую популярность среди как начинающих, так и опытных разработчиков.

Архитектурная траектория Laravel в указанный период характеризуется постепенной интеграцией стандартов PHP-FIG при одновременном сохранении высокоуровневых, локальных абстракций. Ключевым этапом стало принятие Composer \cite{seldaek2012composer} в качестве менеджера зависимостей и внедрение PSR-4 \cite{psr4standard} для автозагрузки классов, что позволило интегрировать Laravel \cite{laraveldocs} в общую экосистему PHP-пакетов и отказаться от проприетарных механизмов загрузки. Поддержка PSR-11 \cite{psr11standard} была реализована частично: собственный контейнер сохранил уникальный API, однако получил совместимость на уровне интерфейсов, обеспечив возможность подключения сторонних библиотек без радикальной перестройки внутренней архитектуры.

Значительным шагом в направлении конвергенции с общеотраслевыми архитектурными практиками стало внедрение middleware-модели, совместимой с PSR-15 \cite{psr15standard}. Несмотря на сохранение собственного контракта для middleware, Laravel \cite{laraveldocs} предоставил механизмы адаптации PSR-совместимых компонентов, что позволило использовать унифицированные подходы к обработке HTTP-запросов без нарушения обратной совместимости.

Эволюция самого языка PHP, в особенности в версиях 7 \cite{php7rfc2015} и 8 \cite{php8typingrfc2020}, оказала прямое влияние на внутреннюю структуру фреймворка. При этом Laravel \cite{laraveldocs} интегрировал новые языковые возможности таким образом, чтобы они не снижали читаемость и выразительность кода, сохранив баланс между архитектурной дисциплиной и удобством использования.

Особую роль в расширении функциональных границ фреймворка сыграло появление специализированных инфраструктурных инструментов — Horizon, Octane, Sail и Pint. Эти компоненты вывели Laravel за пределы традиционного HTTP-слоя, превратив его в полноценную платформу, охватывающую весь жизненный цикл приложения — от локальной разработки и тестирования до эксплуатации в высоконагруженных средах.

В совокупности эти изменения закрепили за Laravel роль центрального элемента стандартизированной PHP-экосистемы. Таким образом, Laravel выступил не только как пассивный реципиент архитектурных трансформаций, но и как активный проводник их в прикладную разработку, оказывая существенное влияние на индустриальные практики и образовательные траектории в PHP-сообществе.

\section{Отклоненные и отложенные инициативы}

Как и в случае с другими устоявшимися программными экосистемами, процесс стандартизации PHP-фреймворков сопровождался не только успешными инициативами, но и значительным числом предложений, которые не были приняты или были сознательно отложены. Анализ этих инициатив представляет особый интерес, поскольку позволяет выявить границы применимости стандартизации и понять, какие архитектурные решения были признаны избыточными, рискованными либо концептуально несоответствующими направлению развития экосистемы.

В данном разделе рассматриваются наиболее показательные инициативы, не приведшие к формированию стандарта. Их анализ позволяет дополнить картину развития PHP-экосистемы и продемонстрировать, что зрелость технологии проявляется не только в способности к унификации, но и в умении своевременно отказаться от чрезмерной стандартизации.

\subsection{Нереализованный стандарт маршрутизации (Router PSR)}

Одной из наиболее обсуждаемых, но так и не реализованных инициатив в рамках PHP-FIG \cite{phpfig2009charter} стало предложение по стандартизации интерфейса маршрутизации HTTP-запросов — Router PSR \cite{figrouterdiscussion}. С 2015 года эта тема неоднократно выносилась на обсуждение в рассылках FIG, что свидетельствует как о её практической актуальности, так и о принципиальных трудностях формализации данного архитектурного уровня.

Потребность в стандарте обусловливалась значительной фрагментацией подходов к маршрутизации в экосистеме PHP. Например, Laravel применял декларативную синтаксическую модель (fluent API) \cite{laravelrouting}, тогда как Symfony использовал аннотации, YAML и PHP-конфигурации \cite{symfonyrouting}. В то же время Slim и Mezzio применяли подход, в котором маршрутизация реализовывалась посредством \textit{middleware} \cite{slimrouting}. Отдельную нишу занимали минималистичные библиотеки вроде FastRoute \cite{fastroute}, реализующие чисто функциональный подход без какой-либо фреймворк-специфической логики. Отсутствие общего интерфейса исключало возможность создания переносимых компонентов — будь то универсальные middleware, инструменты для тестирования маршрутов или декларативные DSL.

Однако в ходе обсуждений в 2016–2018 годах стало очевидно, что различия между этими моделями носят не поверхностный, а концептуальный характер. Controller-based (Laravel \cite{laravelrouting}, Symfony \cite{symfonyrouting}) и middleware-based (Slim \cite{slimrouting}, Mezzio) подходы предполагают разные точки интеграции и жизненные циклы обработки запроса. Попытки выработать единый интерфейс неизменно сталкивались с дилеммой: либо предложить слишком абстрактный контракт, не обеспечивающий практической пользы, либо зафиксировать архитектурные предпочтения одной из моделей, тем самым ограничив свободу проектирования фреймворков.

Ключевым фактором отказа от стандартизации стало также стратегическое стремление PHP-FIG избегать регулирования высокоуровневых архитектурных решений. В условиях активной эволюции подходов к проектированию веб-приложений подобное ограничение было сочтено контрпродуктивным.

В итоге инициатива Router PSR была закрыта как недостаточно универсальная и потенциально ограничивающая. Сообщество пришло к консенсусу: маршрутизация остаётся внутренним делом каждого фреймворка, а взаимодействие между разнородными архитектурами обеспечивается на более низком уровне — через уже устоявшиеся стандарты PSR-7 \cite{psr7standard} и PSR-15 \cite{psr15standard}.

\subsection{Попытка стандартизации ORM и абстракции баз данных}

В экосистеме PHP на протяжении нескольких лет обсуждалась возможность создания стандарта для унифицированного доступа к данным, функционально сопоставимого с JDBC в экосистеме Java. В период с 2014 по 2020 год в рабочих группах и рассылках PHP-FIG неоднократно поднимался вопрос о разработке общего интерфейса для объектно-реляционных отображений (ORM) \cite{figormdiscussion}.

На момент начала обсуждений в PHP-сообществе уже существовало несколько зрелых и широко используемых ORM-решений, включая Doctrine ORM \cite{doctrineorm}, Eloquent ORM \cite{eloquentorm}, Propel \cite{propelorm} и RedBeanPHP \cite{redbeanphp}. Однако эти библиотеки реализовывали принципиально разные архитектурные парадигмы. Doctrine ORM развивалась в русле концепций Domain-Driven Design и паттерна Unit of Work, предполагая строгую типизацию доменных моделей и явное управление жизненным циклом объектов. Eloquent ORM, напротив, следовал классическому паттерну Active Record, интегрируя логику доступа к данным непосредственно в сущности и активно используя динамические методы. Propel делала ставку на генерацию кода на основе декларативных XML-схем, обеспечивая строгую синхронизацию модели с базой данных, тогда как RedBeanPHP предлагала полностью динамический подход, допускающий эволюцию схемы данных в процессе выполнения приложения.

Эти различия оказались не синтаксическими, а концептуальными: каждая модель предполагала особый способ проектирования домена, управления состоянием и взаимодействия с реляционным хранилищем. Дополнительным аргументом против стандартизации стало стремление избежать повторения опыта Java EE, где преждевременная канонизация persistence-слоя привела к усложнению экосистемы.

В итоге инициатива по созданию PSR для ORM была признана нежизнеспособной. Отказ от стандартизации в этой области следует рассматривать не как неудачу, а как осознанный архитектурный выбор: сообщество предпочло сохранить разнообразие культур работы с данными, предоставив разработчикам свободу выбора инструмента, наиболее соответствующего задачам проекта и принятой архитектурной дисциплине.




\subsection{PSR-14 (Event Dispatcher): стандарт, который останется частичным}
PSR-14 \cite{psr14standard} был принят в 2019 году, но его разработка сопровождалась огромным количеством противоречий в рассылках PHP-FIG \cite{figpsr14discussion}.

\subsubsection*{Проблемы}
\begin{itemize}
    \item Фреймворки используют разные event models.
    \begin{itemize}
        \item Symfony: синхронный диспетчер событий, на основе объектных слушателей \cite{symfonyevents}.
        \item Laravel: разделение событий и слушателей + очередь + broadcast \cite{laravalevents}.
        \item Zend Framework: агрегаторы событий \cite{zendEventManager}.
    \end{itemize}
    Найти общую модель оказалось крайне трудно.
    \item Глубокие различия в семантике слушателей.\\
    Например, прекращение обработки событий отсутствует во многих системах.
    \item Слишком узкий охват стандарта.\\
    PSR-14 определяет слишком абстрактный интерфейс:
    \begin{lstlisting}[language=php]
    interface EventDispatcherInterface {
        public function dispatch(object $event): object;
    }
    \end{lstlisting}
\end{itemize}

\subsubsection*{Итог}
PSR-14 принят, но в экосистеме остаётся «вторичным» стандартом.
Существенная часть сообществ его игнорирует.

\subsection{Попытка создания PSR для валидаторов и форм}
Это обсуждение велось эпизодически с 2016 по 2021 годы \cite{figvalidationdiscussion}.

\subsubsection*{Мотивация}
\begin{itemize}
    \item Symfony Form + Validator имеют сложную, но зрелую модель \cite{symfonyform, symfonyvalidator}.
    \item Laravel Validation — декларативная модель со строковыми правилами \cite{laravelvalidation}.
    \item Respect/Validation — функциональная библиотека \cite{respectvalidation}.
\end{itemize}
Наличие множества несовместимых подходов порождало предложение создать переносимый стандарт.

\subsubsection*{Причины отказа}
\begin{itemize}
    \item Слишком разный уровень абстракции.
    \item Слишком разный DSL.\\
    Сравните:
    \begin{itemize}
        \item \graybox{'required|min:6'} (Laravel),
        \item \graybox{new Length(['min'=>6])} (Symfony),
        \item \graybox{v::stringType()->length(6)} (Respect).
    \end{itemize}
    \item Нежелание ограничивать инновации.\\
    Фреймворки активно экспериментируют со схемами данных.
\end{itemize}

\subsubsection*{Итог}
PSR для валидаторов и форм был признан нежизнеспособным.


\subsection{Споры вокруг PSR-18 (HTTP Client)}

PSR-18 \cite{psr18standard} был принят в 2019 году, но с серьёзными дискуссиями \cite{figpsr18discussion}.

\subsubsection*{Причины споров}

\begin{itemize}
    \item Разные модели ошибок (исключения vs error responses).
    \item Различия в реализации Guzzle \cite{guzzlehttp}, HTTPlug \cite{httplug}, Symfony HttpClient \cite{symfonyhttpclient}.
    \item Споры о синхронности vs асинхронности.
\end{itemize}

Некоторые разработчики хотели:

\begin{itemize}
    \item Асинхронный интерфейс (в стиле Promise).
    \item Unified Streaming API.
    \item Поддержку cancellation.
\end{itemize}

FIG решил ограничиться минимальным синхронным интерфейсом, что вызвало критику, но позволило стандартизировать общие ожидания.

\subsubsection*{Итог}

Стандарт был принят как «минимально необходимый», а остальные аспекты намеренно не стандартизированы.

\subsection{Предложение о расширении PSR-11 (унифицированная конфигурация контейнера)}

Иногда обсуждался стандарт для \cite{figpsr11expansion}:

\begin{itemize}
    \item Регистрации сервисов.
    \item Определения параметров.
    \item Описания factories.
\end{itemize}

Это сделало бы DI-контейнеры полностью совместимыми.

\subsubsection*{Причины отказа}

\begin{itemize}
    \item Разные модели конфигурации контейнера.
    \begin{itemize}
        \item Symfony использует YAML/PHP/XML \cite{symfonydependencyinjection}.
        \item Laravel использует bindings и closures \cite{laravelcontainer}.
        \item Laminas: Массивы-конфигурации \cite{laminasdi}.
    \end{itemize}
    Невозможно привести к общему знаменателю.
    \item Опасение закрепления устаревших подходов
    Стандартизация могла заморозить развитие DI.
\end{itemize}

\subsubsection*{Итог}
PSR-11 \cite{psr11standard} остался минималистичным.

\section{Заключение}

За период 2015–2025 годов экосистема PHP-фреймворков претерпела глубокую трансформацию, в результате которой веб-разработка на PHP фактически перешла от фрагментированного набора несовместимых архитектур к единому технологическому пространству, основанному на стандартах и переносимых компонентах.

Ключевую роль в этом процессе сыграли стандарты PHP-FIG (PSR-4, PSR-7, PSR-11, PSR-15), Composer и переход языка к строгой модели типизации в версиях PHP 7 и 8.

Эти изменения оказали системное влияние как на внутренние архитектуры фреймворков, так и на методологию разработки приложений.

Принятие PSR-4 и Composer стало отправной точкой для унификации структуры проектов, что позволило разрушить жёсткие границы между экосистемами разных фреймворков.

Стандартизация HTTP-модели (PSR-7) и middleware-контрактов (PSR-15) сформировала общий слой interoperability, дав толчок развитию кросс-фреймворковых библиотек и middleware-стека.

PSR-11 обеспечил совместимость контейнеров зависимостей, благодаря чему переносимость сервисов и компонентов значительно увеличилась.

Совокупно эти стандарты сформировали основу современной PHP-инфраструктуры, в которой логика приложения теперь отделена от конкретного фреймворка.


Наряду со стандартами FIG значительное влияние оказали изменения в самом языке: строгая типизация, исключительная модель ошибок, увеличение производительности PHP 7, а также атрибуты и JIT-компиляция в PHP 8.

Эти изменения стимулировали фреймворки к переработке внутренних механизмов и улучшению архитектурных практик.

Symfony в этот период окончательно утвердился как компонентный фреймворк, определяющий технические ориентиры для всей PHP-индустрии; Laravel, напротив, стал укреплять свою позицию как высокоуровневый фреймворк, фокусирующийся на удобстве разработки и интеграции с современными DevOps-практиками.

Современные версии обоих фреймворков демонстрируют высокую степень согласованности с PSR-стандартами и активно используют возможности нового PHP.


Особое значение имеют технологии и стандарты, которые не были приняты.

Несостоявшийся PSR для роутинга, отсутствие стандарта для ORM, частичная применимость PSR-14 — всё это демонстрирует, что стандартизация не может и не должна охватывать все аспекты PHP-экосистемы.

Слишком разнообразные архитектуры и различные философии разработки делают некоторые стандарты непрактичными.

В этом смысле отказ от стандартизации отдельных областей оказался не менее ценным, чем успешные инициативы: он позволил индустрии сохранить гибкость и конкурентное разнообразие.

В целом, архитектурная эволюция PHP-фреймворков в 2015–2025 годах может быть охарактеризована как движение к стандартизации на ключевых уровнях абстракции при сохранении свободы в реализации высокоуровневых концепций.

Этот период стал временем консолидации и зрелости: фреймворки перестали быть самостоятельными островами и стали частями единой экосистемы, в которой интерфейсы важнее реализаций, а архитектура — важнее конкретных технологий.

PHP, часто считавшийся устаревающим, за это десятилетие подтвердил свою жизнеспособность, адаптировавшись к современным требованиям производительности, типобезопасности и модульности.

Эта трансформация стала возможной благодаря открытому процессу разработки, публичным обсуждениям в PHP-FIG и активной роли сообществ Symfony и Laravel.

Таким образом, изменения 2015–2025 годов можно считать одним из самых успешных этапов в истории PHP: язык и его фреймворки не только сохранили позиции, но и стали примером того, как открытая стандартизация и согласованные архитектурные решения способны преобразовать зрелую технологию в соответствующую требованиям нового времени.
\setmonofont{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{programming_history}

\end{document}
