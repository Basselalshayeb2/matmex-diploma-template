% !TeX spellcheck = ru_RU
% !TEX root = stommis.tex

\section{Описание решения}
\label{sec:solution}

В разделе описывается реализованный прототип, который захватывает аудиопоток в браузере, выделяет речевые сегменты и передаёт на сервер только те фрагменты, которые относятся к голосовым командам врача.
Далее сервер выполняет распознавание речи и преобразование текста команды в структурированное действие для заполнения полей карты пациента в \textit{STOMMIS}.

\subsection{Архитектура и поток данных}
\label{subsec:arch}

Поток обработки построен как конвейер из клиентской и серверной частей (рис.~\ref{fig:pipeline}).

\begin{figure}[t]
    \centering
    \fbox{\parbox{0.92\linewidth}{
        \textbf{Браузер (рабочее место врача)}\\
        (1) getUserMedia $\rightarrow$ (2) VAD $\rightarrow$ (3) сегменты речи\\
        (4) детектор активации (wake word) $\rightarrow$ (5) сегмент команды\\[0.4em]
        \textbf{Сервер (Flask, в контуре клиники)}\\
        (6) приём файла \texttt{file} $\rightarrow$ (7) транскодирование (при необходимости)\\
        (8) ASR (Yandex SpeechKit) $\rightarrow$ (9) интерпретация команды (rules/LLM)\\
        (10) запись результата в STOMMIS / возврат ответа клиенту
    }}
    \caption{Укрупнённая схема обработки аудиопотока и команд.}
    \label{fig:pipeline}
\end{figure}

Ключевой принцип архитектуры~--- минимизировать «дорогие» операции распознавания речи, выполняя на клиенте лёгкую предварительную фильтрацию (VAD и логика активации).
Это снижает стоимость и сетевую нагрузку, а также уменьшает объём данных, передаваемых за пределы браузера.

\subsection{Клиентский модуль: захват аудио и VAD}
\label{subsec:task1}

Клиентская часть реализована как веб‑страница (HTML + JavaScript + jQuery), которая получает доступ к микрофону и запускает VAD‑движок.
Доступ к микрофону осуществляется через \texttt{getUserMedia}~\cite{MDNGetUserMedia}; обработка аудио выполняется в браузере с использованием Web Audio API~\cite{WebAudioAPI}.

Для выделения речи используется библиотека \texttt{@ricky0123/vad-web}~\cite{RickyVADWebDocs}, предоставляющая событийную модель:
\begin{itemize}
    \item \texttt{onSpeechStart}~--- фиксируется начало речевого сегмента;
    \item \texttt{onSpeechEnd}~--- сегмент считается завершённым после паузы (периода «тишины») заданной длительности;
    \item \texttt{onUpdate}~--- обновление вероятности речи (для визуализации и отладки).
\end{itemize}

Пороговые параметры VAD настраиваются экспериментально под условия кабинета:
\texttt{positiveSpeechThreshold} (чувствительность старта),
\texttt{negativeSpeechThreshold} (чувствительность окончания),
а также \texttt{redemptionFrames}, задающий длительность «тишины» до завершения сегмента.
В прототипе используется правило \enquote{конец команды~--- 2 секунды тишины}, реализуемое через \texttt{redemptionFrames}.

\subsection{Клиентский модуль: активация и выделение команды}
\label{subsec:task2}

Основная проблема непрерывного распознавания речи состоит в том, что на сервер уходит \emph{весь} аудиопоток (включая фоновые разговоры и паузы), что приводит к росту стоимости и нагрузки.
Для решения используется двухэтапная логика:
\begin{enumerate}
    \item \textbf{Режим мониторинга:} VAD работает постоянно, но речевые сегменты не отправляются на сервер.
    \item \textbf{Режим команды:} после обнаружения ключевого слова (например, \enquote{старт}) ближайший речевой сегмент считается командой и отправляется на сервер.
\end{enumerate}

В прототипе предусмотрены два варианта активации:
\begin{itemize}
    \item \textbf{Ручная активация} (кнопка / горячая клавиша)~--- используется как контрольный сценарий и позволяет сравнить качество выделения сегмента команды;
    \item \textbf{Голосовая активация} (wake word)~--- ключевое слово определяется по коротким речевым сегментам, полученным от VAD. Практический вариант для прототипа состоит в проверке ключевого слова по текстовой транскрипции короткого сегмента на сервере (ASR), что позволяет избежать сложной KWS‑модели на клиенте.
\end{itemize}

После активации команда считается завершённой, когда VAD фиксирует паузу заданной длительности.
Получившийся сегмент команды кодируется в аудиофайл и отправляется на сервер как \texttt{multipart/form-data} с полем \texttt{file} (см.~раздел~\ref{subsec:task3}).

\subsection{Серверный модуль: приём аудио, ASR и интерпретация}
\label{subsec:task3}

Серверная часть реализована на Python (Flask) и предоставляет HTTP‑endpoint для приёма командных аудиосегментов.
Клиент отправляет запрос вида:
\begin{itemize}
    \item метод \texttt{POST};
    \item тело \texttt{FormData} c полем \texttt{file};
    \item дополнительные поля метаданных (идентификатор врача, пациента, режим команд), если требуется контекст.
\end{itemize}

На сервере выполняются шаги:
\begin{enumerate}
    \item проверка наличия поля \texttt{file} и чтение байтов аудио в память;
    \item приведение формата аудио к поддерживаемому входу ASR: если MIME‑тип отличается от ожидаемого, выполняется транскодирование в Ogg Opus через \texttt{ffmpeg} по пайпам (без записи на диск)~\cite{FFmpeg};
    \item распознавание речи посредством Yandex SpeechKit~\cite{YandexSpeechKit};
    \item интерпретация результата: преобразование текста в структурированную команду (например, \texttt{intent} + набор параметров), пригодную для заполнения полей карты пациента.
\end{enumerate}

Интерпретация реализуется гибридно: для короткого списка команд задаётся допустимый набор интентов, а для сопоставления свободных формулировок используется LLM‑модуль.
Результат возвращается клиенту в JSON и/или применяется на стороне STOMMIS.

\subsection{Интеграция со STOMMIS и особенности предметной области}
\label{subsec:stommis}

В отличие от решений, ориентированных на «протоколирование» консультации, в рассматриваемом сценарии цель~--- заполнение структурированной карты.
Это требует:
\begin{itemize}
    \item приведения распознанного текста к заранее определённым категориям (диагноз, манипуляция, зуб, рекомендация);
    \item сопоставления со справочниками (например, список процедур и заболеваний), используемыми в STOMMIS;
    \item минимизации количества действий врача в интерфейсе (особенно при работе в перчатках).
\end{itemize}

Командный режим позволяет врачу произносить короткие инструкции, которые конвертируются в конкретные изменения в карте.
Например, команда \enquote{старт, кариес на шестом верхнем справа} может быть интерпретирована как выбор диагноза \enquote{кариес} и установка соответствующего зуба в формуле.

\subsection{Нефункциональные требования: ресурсы и приватность}
\label{subsec:nfr}

Решение спроектировано с учётом ограничений клиники:
\begin{itemize}
    \item \textbf{Ресурсоэффективность:} постоянная работа VAD в браузере должна быть существенно дешевле постоянного ASR;
    \item \textbf{Минимизация трафика:} на сервер отправляются только короткие сегменты команд;
    \item \textbf{Приватность:} исключается постоянная передача полного аудио приёма на сервер; объём передаваемых данных ограничивается командными сегментами.
\end{itemize}

Перечисленные свойства проверяются экспериментально в разделе~\ref{sec:experiment}.
